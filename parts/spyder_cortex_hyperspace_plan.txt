# SPYDER / CORTEX — Hyperespace Plan (v1)

> Fichier destiné à être directement donné à Copilot / QFLUSH comme spécification.
> Objectif : définir précisément comment exploiter les 10 idées “CORTEX / SPYDER”,
> en les reliant à des packets, des handlers, des fichiers, des tests et au format PNG CXPK (OC8 + Brotli).

---

## 0. Contexte général

Ce document formalise un protocole interne pour QFLUSH / SPYDER basé sur :

- des **CortexPackets** (JSON structurés) ;
- un **format PNG CXPK** (header + payload Brotli) pour transporter ces packets dans une image RGBA 8 bits (OC8) ;
- des handlers côté `src/cortex/*` qui appliquent ces packets à l’état du système (`.qflush/*`) ;
- un routeur Cortex (`src/cortex/router.ts`) qui décide quoi faire en runtime ;
- un `qf resonnance` qui démarre un listener Cortex ;
- un `qflush apply` qui consomme des packets (JSON/PNG) en batch et met à jour le système.

Les 10 idées (CORTEX-DRIP, NPZ-GRAPH, OC8-LANG, QUANTUM-ROUTER, SPYDER-SOUND, SAVE-STATE, AUTO-PATCH, SPYDER-VISION, A11-KEY, FUNESTERIE-MAGIE) sont traitées comme **routes Cortex** avec :

- un `type` de packet ;
- une sémantique d’application (`apply`) ;
- un comportement runtime (`router` / SPYDER) ;
- des fichiers cibles dans `.qflush/*` ;
- des règles de sécurité (pour les plus sensibles, ex. AUTO-PATCH, A11-KEY) ;
- des tests unitaires/E2E à prévoir.

Ce fichier est un **plan détaillé**. Copilot peut l’utiliser pour générer/compléter :

- `src/cortex/types.ts`
- `src/cortex/pngCodec.ts`
- `src/cortex/applyPacket.ts`
- `src/cortex/router.ts`
- `src/commands/apply.ts`
- scripts tools (scan/encode/decode PNG/OC8/Brotli)
- tests Vitest

---

## 1. Schéma de base : CortexPacket

### 1.1. Interface TypeScript proposée

```ts
// src/cortex/types.ts

export interface CortexPacket {
  version: number;            // ex: 1
  kind: 'cortex-packet';      // pour distinguer d’autres JSON
  type: string;               // ex: 'cortex:drip', 'cortex:npz-graph', etc.
  id?: string;                // identifiant unique du packet (pour dedupe/log)
  payload: unknown;           // structure dépend du type
}
```

### 1.2. Contrat de validité

Un `CortexPacket` valide doit respecter :

- `version` : entier > 0 ;
- `kind` : exactement `"cortex-packet"` ;
- `type` : string non vide ;
- `payload` : défini (object ou autre structure) ;
- pour les traitements “officiels”, il est recommandé d’exiger un `id` unique.

En cas de packet invalide :

- `applyCortexPacket` doit logguer l’erreur et ignorer le packet (sans casser `apply`) ;
- le routeur runtime peut choisir de l’ignorer silencieusement ou logguer un warning.

---

## 2. Format PNG CXPK (OC8 + Brotli)

L’objectif est de transporter un `CortexPacket` via un PNG RGBA 8 bits, de manière simple et déterministe.

### 2.1. Structure binaire (niveau bas)

- Conteneur : PNG classique, 8 bits par canal, couleur RGBA (OC8)
- Dans le buffer RGBA (ordre `[R,G,B,A, R,G,B,A, ...]`), on range :

**Header (12 octets)**

- `0..3`   : ASCII `"CXPK"`
- `4`      : version du format CXPK, ex. `0x01`
- `5..7`   : réservés (`0x00 0x00 0x00` pour l’instant)
- `8..11`  : longueur du payload (UInt32 Big-Endian)

**Payload**

- `payloadLength` octets représentant un flux Brotli d’un JSON :
  - JSON sérialisé de type `CortexPacket` ;
  - encodé en UTF-8 ;
  - compressé via Brotli.

Les octets header+payload sont ensuite mappés **séquentiellement** sur les canaux RGBA, 4 octets par pixel. Si la longueur totale n’est pas multiple de 4, on pad avec `0x00` jusqu’à remplir le dernier pixel.

### 2.2. Encodeur (concept)

```ts
// encodeCortexPacketToPng(packet, options):
// 1) JSON.stringify(packet) -> Buffer UTF-8
// 2) brotliCompress -> payload: Buffer
// 3) construire header CXPK + length(payload)
// 4) concat(header + payload) = raw
// 5) padding pour multiple de 4
// 6) map raw -> RGBA, width configurable (ex: 128), height calculée
// 7) écrire PNG
```

### 2.3. Décodeur (concept)

```ts
// decodeCortexPacketFromPng(path):
// 1) lire PNG -> buffer RGBA
// 2) raw = buffer RGBA complet (ou extraction R si mode "rideau rouge", selon config)
// 3) vérifier raw[0..3] === 'CXPK'
// 4) version = raw[4]
// 5) length = UInt32BE(raw[8..11])
// 6) payloadBytes = raw[12..12+length]
// 7) brotliDecompress(payloadBytes) -> jsonString
// 8) JSON.parse(jsonString) -> CortexPacket
// 9) valider (kind, version, etc.), renvoyer packet
```

Ce format est **compatible** avec ce que QFLUSH a déjà commencé à implémenter (CXPK).

---

## 3. Pipeline QFLUSH / SPYDER autour des packets

### 3.1. Entrées de packets

Racine : `.qflush/`

- `.qflush/incoming/json/*.json` : fichiers CortexPacket en JSON brut
- `.qflush/incoming/png/*.png`   : fichiers PNG CXPK (voir §2)
- `.qflush/processed/YYYY-MM/…` : fichiers déjà traités (archivés)

### 3.2. Commande apply

`src/commands/apply.ts` (ou équivalent CLI) doit :

1. Garantir que `.qflush/` existe.
2. Scanner `incoming/json` et `incoming/png` pour collecter des packets :
   - JSON : parse direct en `CortexPacket` ;
   - PNG : via `decodeCortexPacketFromPng`.
3. **Dédoublonnage** :
   - lire `.qflush/spyder.cache.json` ;
   - structure recommandée :
     ```json
     {
       "appliedPacketIds": ["id-1", "id-2", "..."]
     }
     ```
   - si `packet.id` est déjà présent → ignorer gentiment (log + skip).
4. Appliquer chaque packet via `applyCortexPacket(packet)`.
5. Archiver les fichiers sources :
   - déplacer dans `.qflush/processed/YYYY-MM/<nomOriginal>`
6. Mettre à jour `.qflush/spyder.cache.json` avec les nouveaux `id`.

### 3.3. Résumé des fichiers système utilisés

- `.qflush/cortex.routes.json` : routes Cortex + scores + enabled
- `.qflush/spyder.config.json`  : état global de SPYDER (enabled, mode, etc.)
- `.qflush/spyder.cache.json`   : packet ids déjà appliqués
- `.qflush/cortex/drip.log`     : log d’événements CORTEX-DRIP
- `.qflush/npz.graph.json`      : graphe NPZ/links
- `.qflush/oc8.meta.json`       : metadata sur le format OC8
- `.qflush/spyder-sound.config.json` : config SPYDER-SOUND
- `.qflush/state-*.json`        : snapshots d’état (SAVE-STATE)
- `.qflush/config.json`         : config QFLUSH patchable (AUTO-PATCH)
- `.qflush/patches/*.json`      : journaux de patch (AUTO-PATCH)
- `.qflush/spyder-vision.json`  : résultats d’analyse d’images
- `.qflush/a11.config.json`     : config pour A11 (clé, endpoint, etc.)
- `.qflush/magic.log`           : journal FUNESTERIE-MAGIE

---

## 4. Spécification des 10 routes / idées

Dans ce qui suit, `type` = valeur attendue dans `packet.type`.

Chaque route a :

- un rôle fonctionnel (but) ;
- un comportement côté `apply` (effet sur les fichiers) ;
- un comportement runtime côté `router` (Handlers SPYDER/CORTEX) ;
- des remarques sur la sécurité et les tests.

### 4.1. CORTEX-DRIP

- `name`  : `"CORTEX-DRIP"`
- `type`  : `"cortex:drip"`
- **But** : Streaming léger d’événements / télémétrie. Ne doit **jamais casser** le pipeline.

#### Payload recommandé

```ts
interface CortexDripPayload {
  level?: 'debug' | 'info' | 'warn' | 'error';
  source?: string;          // ex: "npz/ingest", "daemon/start"
  message: string;
  meta?: Record<string, unknown>;
}
```

#### Comportement `apply`

- `applyCortexPacket` pour `type === 'cortex:drip'` :
  - ouvre `.qflush/cortex/drip.log` en append ;
  - écrit une ligne JSONL avec `{ id, timestamp, type, payload }` ;
  - ne modifie aucun autre fichier ;
  - ne jette pas d’exception fatale (catch + log error).

#### Comportement runtime (router)

- `router.handleDrip(packet: CortexPacket)` :
  - peut être appelé par des composants internes via une fonction `cortex.emit('drip', payload)` ;
  - log console + éventuellement envoie vers `drip.log` aussi ;
  - ne doit jamais bloquer ni faire échouer une opération métier.

#### Tests

- Vitest pour `applyCortexPacket` :
  - donnée un `CortexPacket` valide `cortex:drip` ;
  - après `apply`, vérifier présence d’une nouvelle ligne dans `drip.log` ;
  - vérifier que l’exception ne remonte pas même si le log n’existe pas au début.

---

### 4.2. NPZ-GRAPH

- `name`  : `"NPZ-GRAPH"`
- `type`  : `"cortex:npz-graph"`
- **But** : Ingérer / fusionner des infos de graphe dans `.qflush/npz.graph.json` (ou équivalent).

#### Payload recommandé

```ts
interface NpzGraphNode {
  id: string;
  kind?: string;                 // ex: "project", "module", "route"
  label?: string;
  meta?: Record<string, unknown>;
}

interface NpzGraphEdge {
  from: string;
  to: string;
  rel?: string;                  // ex: "uses", "depends-on"
  meta?: Record<string, unknown>;
}

interface CortexNpzGraphPayload {
  nodes?: NpzGraphNode[];
  edges?: NpzGraphEdge[];
}
```

#### Comportement `apply`

- Lire `.qflush/npz.graph.json` si existe, sinon initialiser :
  ```json
  { "nodes": [], "edges": [] }
  ```
- Fusionner :
  - pour `nodes` : clé primaire par `id` (si déjà présent, merge `kind`, `label`, `meta`) ;
  - pour `edges` : possibilité d’autoriser les doublons ou d’unicité `(from,to,rel)`.
- Réécrire le fichier avec le graphe fusionné.

#### Comportement runtime (router)

- `router.handleNpzGraph(packet)` :
  - peut éventuellement déclencher une mise à jour en mémoire du graphe NPZ dans SPYDER ;
  - ou laisser l’application offline à `apply` dans un premier temps.

#### Tests

- Vitest pour `applyCortexPacket` avec `cortex:npz-graph` :
  - cas initial (pas de fichier) ;
  - cas fusion (fichier existant, nouveaux nodes/edges).

---

### 4.3. OC8-LANG

- `name`  : `"OC8-LANG"`
- `type`  : `"cortex:oc8"`
- **But** : Déclarer / documenter le format OC8 + lancer des self-tests.

#### Payload recommandé

```ts
interface CortexOc8Payload {
  action: 'register-format' | 'self-test';
  info?: {
    name?: string;                // "OC8"
    description?: string;
  };
}
```

#### Comportement `apply`

- Si `action === 'register-format'` :
  - mettre à jour `.qflush/oc8.meta.json` avec une structure du genre :
    ```json
    {
      "name": "OC8",
      "description": "RGBA 8-bit channels + CXPK header + Brotli(CortexPacket)"
    }
    ```
- Si `action === 'self-test'` :
  - optionnel : encoder un petit packet, le décoder, vérifier que ça rond-trip bien ;
  - logguer le résultat dans `drip.log` ou console.

#### Runtime

- `router.handleOc8(packet)` peut :
  - lancer ou logguer le self-test ;
  - retourner un statut interne.

---

### 4.4. QUANTUM-ROUTER

- `name`  : `"QUANTUM-ROUTER"`
- `type`  : `"cortex:qrouter"`
- **But** : Maintenir un fichier de configuration de routes Cortex avec `enabled` + `score`.

#### Payload recommandé

```ts
interface RouteConfig {
  enabled?: boolean;
  score?: number;           // priorité, 0–100
}

interface CortexQRouterPayload {
  routes: Record<string, RouteConfig>; // clé = packet.type
}
```

#### Fichier `.qflush/cortex.routes.json` (structure cible)

```json
{
  "cortex:drip":       { "enabled": true, "score": 10 },
  "cortex:npz-graph":  { "enabled": true, "score": 90 },
  "cortex:save-state": { "enabled": true, "score": 80 }
}
```

#### Comportement `apply`

- Lire le fichier existant si présent, sinon initialiser `{}`.
- Fusionner : pour chaque entrée de `payload.routes`, écraser ou compléter la config.
- Réécrire `.qflush/cortex.routes.json`.

#### Runtime

- `router.ts` lit ce fichier au démarrage (ou à chaud) et :

  - n’exécute un handler **que si** `enabled === true` ;
  - peut utiliser `score` pour prioriser des handlers concurrents s’il y a un mécanisme de compétition.

---

### 4.5. SPYDER-SOUND

- `name`  : `"SPYDER-SOUND"`
- `type`  : `"cortex:spyder-sound"`
- **But** : Centraliser une config sonore / télémétrie sonore (webhook, profil).

#### Payload recommandé

```ts
interface CortexSpyderSoundPayload {
  webhookUrl?: string;
  profile?: string;     // ex: "default", "r2d2", "alarm"
}
```

#### Fichier cible

- `.qflush/spyder-sound.config.json`

#### Comportement `apply`

- Merge simple de la config dans ce fichier.

#### Runtime

- `router.handleSpyderSound(packet)` :
  - logguer un event `"spyder-sound"` ;
  - éventuellement déclencher un webhook ou une génération audio (futur).

---

### 4.6. SAVE-STATE

- `name`  : `"SAVE-STATE"`
- `type`  : `"cortex:save-state"`
- **But** : Snapshot JSON de l’état de QFLUSH (configs, routes, etc.).

#### Payload recommandé

```ts
interface CortexSaveStatePayload {
  reason?: string;           // ex: "pre-upgrade", "manual"
}
```

#### Comportement `apply`

- Construire un objet `state` :
  - éventuellement : lecture de certains fichiers clés (.qflush/config.json, cortex.routes.json, spyder.config.json, npz.graph.json...) ;
- Écrire le snapshot dans un fichier du type :
  - `.qflush/state-YYYYMMDD-HHMMSS.json` ;
- Logguer l’opération dans `drip.log` ou console.

#### Runtime

- `router.handleSaveState(packet)` peut déclencher la même logique à chaud (hors apply), par exemple avant une opération risquée.

---

### 4.7. AUTO-PATCH

- `name`  : `"AUTO-PATCH"`
- `type`  : `"cortex:auto-patch"`
- **But** : Appliquer des patchs sur `.qflush/config.json` de manière sécurisée.

#### Payload recommandé

```ts
interface CortexAutoPatchPayload {
  patch: Record<string, unknown>;  // partiel, ex: { "flags": { "disableRedis": true } }
  dryRun?: boolean;                // si true, ne pas écrire, juste simuler
}
```

#### Règles de sécurité

- Liste blanche (whitelist) des clés modifiables (ex: `flags`, `paths`, `services`) ;
- `dryRun` par défaut à **true** si non précisé ;
- pour une application réelle, exiger un flag CLI type `qflush apply --approve-autopatch` ;
- journaliser chaque patch dans `.qflush/patches/patch-<id>.json` (avant/après).

#### Comportement `apply`

- Lire `.qflush/config.json` (ou `{}` si absent) ;
- Calculer `mergedConfig` avec le patch ;
- Si `dryRun === true` :
  - ne pas écrire, mais logguer le diff ;
- Sinon :
  - écrire la nouvelle config ;
  - écrire un journal dans `.qflush/patches/patch-<id>.json`.

---

### 4.8. SPYDER-VISION

- `name`  : `"SPYDER-VISION"`
- `type`  : `"cortex:spyder-vision"`
- **But** : Analyser des PNG (pattern / métadonnées) et produire un JSON d’analyse.

#### Payload recommandé

```ts
interface CortexSpyderVisionPayload {
  imagePath: string;            // chemin vers un PNG à analyser
  tags?: string[];              // tags optionnels
}
```

#### Fichier cible

- `.qflush/spyder-vision.json` :
  ```json
  {
    "items": [
      {
        "imagePath": "...",
        "tags": ["oc8", "cortex-dump"],
        "meta": { "width": 128, "height": 512, "entropy": 0.92 }
      }
    ]
  }
  ```

#### Comportement `apply`

- Lire le PNG indiqué (`imagePath`) ;
- Extraire des infos de base (dimensions, entropie approximative) ;
- Optionnel : tenter de décoder CXPK s’il est au format OC8 ;
- Ajouter une entrée dans `spyder-vision.json`.

---

### 4.9. A11-KEY

- `name`  : `"A11-KEY"`
- `type`  : `"cortex:a11-key"`
- **But** : Enregistrer une config pour l’IA locale A11 (clé, endpoint, etc.).

#### Payload recommandé

```ts
interface CortexA11KeyPayload {
  endpoint?: string;
  apiKey?: string;         // ⚠️ sensible
  model?: string;          // ex: "llama3.1:latest"
}
```

#### Règles de sécurité

- **Ne jamais logguer** `apiKey` en clair ;
- Fichier cible `.qflush/a11.config.json` :
  - permettre une version plus tard chiffrée ;
- Journaliser uniquement des infos non sensibles (ex: “a11 config updated”).

#### Comportement `apply`

- Merge simple dans `.qflush/a11.config.json` ;
- Si `apiKey` présent, ne pas l’écrire dans les logs.

---

### 4.10. FUNESTERIE-MAGIE

- `name`  : `"FUNESTERIE-MAGIE"`
- `type`  : `"cortex:magic"`
- **But** : Espace de jeu / hooks expérimentaux, non critique.

#### Payload recommandé

```ts
interface CortexMagicPayload {
  spell?: string;             // ex: "log-only", "test-route"
  note?: string;
  meta?: Record<string, unknown>;
}
```

#### Fichier cible

- `.qflush/magic.log` (append JSONL).

#### Rôle

- Permet de tester rapidement des intégrations SPYDER sans impacter les flux sérieux.

---

## 5. Cross-cutting : dedupe, archival, resonnance, tests

### 5.1. Dédoublonnage

- Fichier : `.qflush/spyder.cache.json`
- Structure :
  ```json
  {
    "appliedPacketIds": ["id-1", "id-2", "..."]
  }
  ```
- Logique :
  - avant `applyCortexPacket(packet)` :
    - si `packet.id` est défini ET déjà présent dedans → skip (log “duplicate packet”), ne pas réappliquer ;
  - après un apply réussi → ajouter `id` à la liste et réécrire le fichier.

### 5.2. Archivage

- Après un `apply` réussi, les fichiers sources JSON/PNG doivent être déplacés vers :
  - `.qflush/processed/YYYY-MM/<nomOriginal>` ;
- Cela évite de les retraiter au prochain `apply` ;
- Option : flag CLI `--keep-incoming` pour débogage.

### 5.3. Activation automatique de la résonnance

- Règle suggérée :
  - `qflush start` doit démarrer `resonnance` (listener Cortex) si :
    - `spyder.config.json.enabled === true` **OU**
    - il existe au moins une route Cortex enabled (dans `cortex.routes.json`).

### 5.4. Tests recommandés

- **pngRoundTrip** :  
  - encoder un `CortexPacket` en PNG CXPK, le décoder, comparer l’objet ;
- **applyPacket** :  
  - pour chaque type core (`cortex:drip`, `cortex:npz-graph`, `cortex:save-state`, `cortex:auto-patch`) -> vérifier les effets sur les fichiers ;
- **routerDispatch** :  
  - router lit `cortex.routes.json` et n’appelle que les handlers `enabled === true` ;
  - tester la prise en compte de `score` si la logique de priorité est implémentée.

---

## 6. Résumé pour Copilot (guideline courte)

1. Utiliser ce fichier comme **spécification** pour compléter :  
   - `src/cortex/types.ts`  
   - `src/cortex/pngCodec.ts`  
   - `src/cortex/applyPacket.ts`  
   - `src/cortex/router.ts`  
   - `src/commands/apply.ts`  
   - et les tests Vitest associés.

2. Respecter strictement les `type` de packet :  
   - `"cortex:drip"`  
   - `"cortex:npz-graph"`  
   - `"cortex:oc8"`  
   - `"cortex:qrouter"`  
   - `"cortex:spyder-sound"`  
   - `"cortex:save-state"`  
   - `"cortex:auto-patch"`  
   - `"cortex:spyder-vision"`  
   - `"cortex:a11-key"`  
   - `"cortex:magic"`  

3. Implémenter `applyCortexPacket(packet)` comme un dispatcher central, en utilisant les règles ci-dessus pour chaque type.

4. Optionnellement, ajouter des helpers (`cortex.emit`, `startCortexListener`, etc.) qui utilisent ces mêmes types en runtime.

Fin du plan v1 (mode hyperespace).