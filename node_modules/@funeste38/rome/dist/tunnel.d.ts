/** Configuration du tunnel */
export interface TunnelConfig {
    port: number;
    subdomain?: string;
    host?: string;
    authToken?: string;
}
/** État du tunnel */
export interface TunnelStatus {
    isRunning: boolean;
    url?: string;
    pid?: number;
    port?: number;
    lastChecked: Date;
}
/** Gestionnaire de tunnel intégré */
export declare class TunnelManager {
    private status;
    private config;
    constructor(config?: TunnelConfig);
    /** Configure le port */
    setPort(port: number): void;
    /** Démarre le tunnel */
    start(): Promise<TunnelStatus>;
    /** Arrête le tunnel */
    stop(): Promise<void>;
    /** Vérifie le statut du tunnel */
    checkStatus(): Promise<TunnelStatus>;
    /** Teste la connectivité du tunnel */
    testConnectivity(): Promise<{
        success: boolean;
        responseTime?: number;
        statusCode?: number;
    }>;
    /** Effectue des tests complets */
    runTests(): Promise<{
        connectivity: boolean;
        endpoints: Array<{
            url: string;
            success: boolean;
            statusCode?: number;
        }>;
    }>;
    /** Lance un terminal split pour monitoring */
    launchSplitTerminal(): Promise<void>;
    /** Lance le lanceur automatique */
    launchAutoLauncher(): Promise<void>;
    private checkNgrokInstalled;
    private checkPortFree;
    private waitForTunnelReady;
    private getTunnelUrl;
    private createSplitTerminalScript;
    private createAutoLauncherScript;
}
export declare const tunnelManager: TunnelManager;
