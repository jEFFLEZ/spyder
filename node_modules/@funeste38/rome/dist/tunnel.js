import { spawn } from "child_process";
import fs from "fs";
import path from "path";
import { createServer } from "net";
/** Gestionnaire de tunnel int√©gr√© */
export class TunnelManager {
    status = {
        isRunning: false,
        lastChecked: new Date()
    };
    config;
    constructor(config = { port: 3000 }) {
        this.config = config;
    }
    /** Configure le port */
    setPort(port) {
        this.config.port = port;
    }
    /** D√©marre le tunnel */
    async start() {
        try {
            // V√©rifier si ngrok est install√©
            const ngrokInstalled = await this.checkNgrokInstalled();
            if (!ngrokInstalled) {
                throw new Error("ngrok n'est pas install√©. Installez-le depuis https://ngrok.com/download");
            }
            // V√©rifier si le port est occup√©
            const portFree = await this.checkPortFree(this.config.port);
            if (!portFree) {
                throw new Error(`Le port ${this.config.port} n'est pas disponible`);
            }
            // D√©marrer ngrok
            const ngrokProcess = spawn('ngrok', [
                'http',
                this.config.port.toString(),
                '--log=stdout'
            ], {
                detached: true,
                stdio: ['ignore', 'pipe', 'pipe']
            });
            // Attendre que ngrok soit pr√™t
            await this.waitForTunnelReady(ngrokProcess);
            // R√©cup√©rer l'URL du tunnel
            const tunnelUrl = await this.getTunnelUrl();
            this.status = {
                isRunning: true,
                url: tunnelUrl,
                pid: ngrokProcess.pid,
                port: this.config.port,
                lastChecked: new Date()
            };
            return this.status;
        }
        catch (error) {
            throw new Error(`Erreur lors du d√©marrage du tunnel: ${error}`);
        }
    }
    /** Arr√™te le tunnel */
    async stop() {
        if (this.status.pid) {
            try {
                process.kill(this.status.pid, 'SIGTERM');
                // Attendre un peu pour que le processus se termine proprement
                await new Promise(resolve => setTimeout(resolve, 2000));
            }
            catch (error) {
                // Forcer l'arr√™t si n√©cessaire
                try {
                    process.kill(this.status.pid, 'SIGKILL');
                }
                catch { }
            }
        }
        // Tuer tous les processus ngrok restants
        try {
            if (process.platform === 'win32') {
                spawn('taskkill', ['/f', '/im', 'ngrok.exe'], { stdio: 'ignore' });
            }
            else {
                spawn('pkill', ['-f', 'ngrok'], { stdio: 'ignore' });
            }
        }
        catch { }
        this.status = {
            isRunning: false,
            lastChecked: new Date()
        };
    }
    /** V√©rifie le statut du tunnel */
    async checkStatus() {
        try {
            const tunnelUrl = await this.getTunnelUrl();
            this.status.url = tunnelUrl;
            this.status.isRunning = !!tunnelUrl;
        }
        catch {
            this.status.isRunning = false;
            this.status.url = undefined;
        }
        this.status.lastChecked = new Date();
        return this.status;
    }
    /** Teste la connectivit√© du tunnel */
    async testConnectivity() {
        if (!this.status.url) {
            return { success: false };
        }
        try {
            const startTime = Date.now();
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 10000);
            const response = await fetch(this.status.url, {
                signal: controller.signal,
                headers: {
                    'User-Agent': 'Rome-Tunnel-Test/1.0'
                }
            });
            clearTimeout(timeoutId);
            const responseTime = Date.now() - startTime;
            return {
                success: response.ok,
                responseTime,
                statusCode: response.status
            };
        }
        catch (error) {
            return { success: false };
        }
    }
    /** Effectue des tests complets */
    async runTests() {
        const connectivity = (await this.testConnectivity()).success;
        const endpoints = [];
        if (this.status.url) {
            // Test des endpoints communs
            const testEndpoints = [
                '',
                '/api/health',
                '/api/diagnostic',
                '/health',
                '/status'
            ];
            for (const endpoint of testEndpoints) {
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 5000);
                    const response = await fetch(`${this.status.url}${endpoint}`, {
                        signal: controller.signal,
                        headers: {
                            'User-Agent': 'Rome-Tunnel-Test/1.0'
                        }
                    });
                    clearTimeout(timeoutId);
                    endpoints.push({
                        url: endpoint || '/',
                        success: response.ok,
                        statusCode: response.status
                    });
                }
                catch {
                    endpoints.push({
                        url: endpoint || '/',
                        success: false
                    });
                }
            }
        }
        return { connectivity, endpoints };
    }
    /** Lance un terminal split pour monitoring */
    async launchSplitTerminal() {
        const scriptPath = path.join(process.cwd(), 'scripts', 'split-terminal.ps1');
        if (!fs.existsSync(scriptPath)) {
            // Cr√©er le script PowerShell si inexistant
            await this.createSplitTerminalScript(scriptPath);
        }
        // Lancer le script PowerShell
        spawn('powershell', ['-ExecutionPolicy', 'Bypass', '-File', scriptPath], {
            stdio: 'inherit',
            detached: true
        });
    }
    /** Lance le lanceur automatique */
    async launchAutoLauncher() {
        const scriptPath = path.join(process.cwd(), 'scripts', 'auto-launch.ps1');
        if (!fs.existsSync(scriptPath)) {
            // Cr√©er le script si inexistant
            await this.createAutoLauncherScript(scriptPath);
        }
        spawn('powershell', ['-ExecutionPolicy', 'Bypass', '-File', scriptPath], {
            stdio: 'inherit',
            detached: true
        });
    }
    async checkNgrokInstalled() {
        return new Promise((resolve) => {
            const check = spawn('ngrok', ['version'], { stdio: 'ignore' });
            check.on('close', (code) => resolve(code === 0));
            check.on('error', () => resolve(false));
        });
    }
    async checkPortFree(port) {
        return new Promise((resolve) => {
            const server = createServer();
            server.listen(port, () => {
                server.close();
                resolve(true);
            });
            server.on('error', () => resolve(false));
        });
    }
    async waitForTunnelReady(process) {
        return new Promise((resolve, reject) => {
            let ready = false;
            const timeout = setTimeout(() => {
                if (!ready) {
                    reject(new Error('Timeout: ngrok ne s\'est pas lanc√© dans les d√©lais'));
                }
            }, 10000);
            process.stdout?.on('data', (data) => {
                const output = data.toString();
                if (output.includes('started tunnel') || output.includes('client session established')) {
                    ready = true;
                    clearTimeout(timeout);
                    resolve();
                }
            });
            process.on('close', (code) => {
                if (code !== 0 && !ready) {
                    clearTimeout(timeout);
                    reject(new Error(`ngrok s'est arr√™t√© avec le code ${code}`));
                }
            });
        });
    }
    async getTunnelUrl() {
        return new Promise((resolve) => {
            const curl = spawn('curl', ['http://localhost:4040/api/tunnels'], { stdio: ['ignore', 'pipe', 'ignore'] });
            let output = '';
            curl.stdout?.on('data', (data) => {
                output += data.toString();
            });
            curl.on('close', () => {
                try {
                    const data = JSON.parse(output);
                    const tunnel = data.tunnels?.find((t) => t.proto === 'https');
                    resolve(tunnel?.public_url);
                }
                catch {
                    resolve(undefined);
                }
            });
            curl.on('error', () => resolve(undefined));
        });
    }
    async createSplitTerminalScript(scriptPath) {
        const script = `
# Script de terminal split pour Rome Tunnel
param(
    [int]$Port = 3000
)

Write-Host "üöÄ Rome Tunnel - Terminal Split" -ForegroundColor Cyan
Write-Host "=================================" -ForegroundColor Cyan

# Fonction pour cr√©er un onglet Windows Terminal
function New-TerminalTab {
    param([string]$Command, [string]$Title)

    $wtCommand = "wt.exe new-tab --title \\"$Title\\" powershell.exe -NoExit -Command \\"$Command\\""
    Start-Process -FilePath "cmd.exe" -ArgumentList "/c $wtCommand" -NoNewWindow
}

# Onglet 1: Serveur de d√©veloppement
$serverCommand = "cd '${process.cwd()}'; npm run dev"
New-TerminalTab -Command $serverCommand -Title "Rome Server (Port $Port)"

Start-Sleep -Seconds 2

# Onglet 2: Tunnel ngrok
$tunnelCommand = "cd '${process.cwd()}'; ngrok http $Port --log=stdout"
New-TerminalTab -Command $tunnelCommand -Title "Rome Tunnel (ngrok)"

Start-Sleep -Seconds 3

# Onglet 3: Monitoring et tests
$monitorCommand = @"
cd '${process.cwd()}'
Write-Host 'üîç Monitoring du tunnel...' -ForegroundColor Yellow
while (\$true) {
    try {
        \$response = Invoke-WebRequest -Uri 'http://localhost:4040/api/tunnels' -TimeoutSec 5
        \$data = \$response.Content | ConvertFrom-Json
        \$tunnel = \$data.tunnels | Where-Object { \$_.proto -eq 'https' } | Select-Object -First 1

        if (\$tunnel) {
            Write-Host "‚úÖ Tunnel actif: \$(\$tunnel.public_url)" -ForegroundColor Green

            # Test de connectivit√©
            try {
                \$testResponse = Invoke-WebRequest -Uri \$tunnel.public_url -TimeoutSec 10
                Write-Host "‚úÖ Connectivit√© OK (Status: \$(\$testResponse.StatusCode))" -ForegroundColor Green
            } catch {
                Write-Host "‚ùå Erreur de connectivit√©" -ForegroundColor Red
            }
        } else {
            Write-Host "‚ùå Aucun tunnel trouv√©" -ForegroundColor Red
        }
    } catch {
        Write-Host "‚ùå Impossible de contacter ngrok" -ForegroundColor Red
    }

    Start-Sleep -Seconds 10
}
"@
New-TerminalTab -Command $monitorCommand -Title "Rome Monitor"

Write-Host "‚úÖ Terminaux split lanc√©s !" -ForegroundColor Green
Write-Host "Utilisez Ctrl+C dans chaque onglet pour arr√™ter" -ForegroundColor Yellow
`;
        await fs.promises.mkdir(path.dirname(scriptPath), { recursive: true });
        await fs.promises.writeFile(scriptPath, script, 'utf8');
    }
    async createAutoLauncherScript(scriptPath) {
        const script = `
# Lanceur automatique Rome Tunnel
param(
    [int]$Port = 3000,
    [switch]$NoSplit
)

Write-Host "üöÄ Rome Tunnel - Auto Launcher" -ForegroundColor Cyan
Write-Host "===============================" -ForegroundColor Cyan

# Fonction de nettoyage
function Cleanup {
    Write-Host "üßπ Nettoyage..." -ForegroundColor Yellow
    Get-Process | Where-Object { $_.ProcessName -eq 'ngrok' } | Stop-Process -Force -ErrorAction SilentlyContinue
    Get-Process | Where-Object { $_.ProcessName -eq 'node' -and $_.CommandLine -like '*dev*' } | Stop-Process -Force -ErrorAction SilentlyContinue
}

# Gestionnaire d'arr√™t propre
$handler = {
    Write-Host "üõë Arr√™t demand√©..." -ForegroundColor Yellow
    Cleanup
    exit 0
}

# Enregistrer les gestionnaires d'arr√™t
[Console]::TreatControlCAsInput = $false
Register-ObjectEvent -InputObject ([Console]) -EventName CancelKeyPress -Action $handler | Out-Null

try {
    # √âtape 1: V√©rifier les pr√©requis
    Write-Host "üîç V√©rification des pr√©requis..." -ForegroundColor Yellow

    # V√©rifier npm
    if (!(Get-Command npm -ErrorAction SilentlyContinue)) {
        throw "npm n'est pas install√©"
    }

    # V√©rifier ngrok
    if (!(Get-Command ngrok -ErrorAction SilentlyContinue)) {
        throw "ngrok n'est pas install√©. T√©l√©chargez-le depuis https://ngrok.com/download"
    }

    # V√©rifier le port
    $portInUse = Test-NetConnection -ComputerName localhost -Port $Port -WarningAction SilentlyContinue
    if ($portInUse.TcpTestSucceeded) {
        throw "Le port $Port est d√©j√† utilis√©"
    }

    Write-Host "‚úÖ Pr√©requis OK" -ForegroundColor Green

    # √âtape 2: Lancer le serveur en arri√®re-plan
    Write-Host "üöÄ D√©marrage du serveur..." -ForegroundColor Yellow
    $serverJob = Start-Job -ScriptBlock {
        param($workingDir)
        Set-Location $workingDir
        npm run dev
    } -ArgumentList '${process.cwd()}'

    # Attendre que le serveur d√©marre
    Start-Sleep -Seconds 5

    # √âtape 3: Lancer ngrok en arri√®re-plan
    Write-Host "üåê D√©marrage du tunnel..." -ForegroundColor Yellow
    $tunnelJob = Start-Job -ScriptBlock {
        param($port)
        ngrok http $port --log=stdout
    } -ArgumentList $Port

    # Attendre que ngrok soit pr√™t
    Start-Sleep -Seconds 5

    # √âtape 4: Tests de connectivit√©
    Write-Host "üß™ Tests de connectivit√©..." -ForegroundColor Yellow

    $maxRetries = 10
    $retryCount = 0
    $tunnelUrl = $null

    while ($retryCount -lt $maxRetries -and !$tunnelUrl) {
        try {
            $response = Invoke-WebRequest -Uri 'http://localhost:4040/api/tunnels' -TimeoutSec 5
            $data = $response.Content | ConvertFrom-Json
            $tunnel = $data.tunnels | Where-Object { $_.proto -eq 'https' } | Select-Object -First 1
            if ($tunnel) {
                $tunnelUrl = $tunnel.public_url
            }
        } catch {
            # Ignorer les erreurs temporaires
        }

        if (!$tunnelUrl) {
            $retryCount++
            Write-Host "‚è≥ Attente du tunnel... ($retryCount/$maxRetries)" -ForegroundColor Yellow
            Start-Sleep -Seconds 2
        }
    }

    if (!$tunnelUrl) {
        throw "Impossible d'obtenir l'URL du tunnel apr√®s $maxRetries tentatives"
    }

    Write-Host "‚úÖ Tunnel actif: $tunnelUrl" -ForegroundColor Green

    # √âtape 5: Tests des endpoints
    Write-Host "üîç Test des endpoints..." -ForegroundColor Yellow

    $endpoints = @('/', '/api/health', '/api/diagnostic', '/health', '/status')
    foreach ($endpoint in $endpoints) {
        try {
            $response = Invoke-WebRequest -Uri "$tunnelUrl$endpoint" -TimeoutSec 10
            Write-Host "‚úÖ $endpoint - Status: $($response.StatusCode)" -ForegroundColor Green
        } catch {
            Write-Host "‚ùå $endpoint - √âchec" -ForegroundColor Red
        }
    }

    # √âtape 6: Monitoring continu
    Write-Host "üìä Monitoring continu (Ctrl+C pour arr√™ter)..." -ForegroundColor Cyan
    Write-Host "Serveur: Job $($serverJob.Id)" -ForegroundColor Gray
    Write-Host "Tunnel: Job $($tunnelJob.Id)" -ForegroundColor Gray

    while ($true) {
        try {
            # V√©rifier que les jobs sont toujours actifs
            if ($serverJob.State -ne 'Running') {
                Write-Host "‚ùå Le serveur s'est arr√™t√©" -ForegroundColor Red
                break
            }
            if ($tunnelJob.State -ne 'Running') {
                Write-Host "‚ùå Le tunnel s'est arr√™t√©" -ForegroundColor Red
                break
            }

            # Test rapide de connectivit√©
            $response = Invoke-WebRequest -Uri $tunnelUrl -TimeoutSec 5
            Write-Host "‚úÖ Tunnel OK - $(Get-Date -Format 'HH:mm:ss')" -ForegroundColor Green
        } catch {
            Write-Host "‚ùå Erreur de connectivit√© - $(Get-Date -Format 'HH:mm:ss')" -ForegroundColor Red
        }

        Start-Sleep -Seconds 30
    }

} catch {
    Write-Host "‚ùå Erreur: $_" -ForegroundColor Red
} finally {
    Write-Host "üõë Arr√™t en cours..." -ForegroundColor Yellow
    Cleanup
    Write-Host "‚úÖ Nettoyage termin√©" -ForegroundColor Green
}
`;
        await fs.promises.mkdir(path.dirname(scriptPath), { recursive: true });
        await fs.promises.writeFile(scriptPath, script, 'utf8');
    }
}
// Instance globale
export const tunnelManager = new TunnelManager();
