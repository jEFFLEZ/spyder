#!/usr/bin/env node
import { runOne } from "./run.js";
import { duo } from "./duo.js";
import { trio } from "./trio.js";
import { loadConfig, mergeConfig, parseOutputOptions, resolveOutputOptions } from "./config.js";
import { createGlobalLogger } from "./logger.js";
// Charge la config et parse les options d'affichage
const config = mergeConfig(loadConfig());
const cliOutputOptions = parseOutputOptions(process.argv.slice(2));
const outputOptions = resolveOutputOptions(cliOutputOptions, config.output);
// CrÃ©e le logger global avec les options d'affichage
const globalLogger = createGlobalLogger(outputOptions);
// Filtre les arguments pour enlever les options d'affichage
const args = process.argv.slice(2).filter(arg => !['--plain', '--json', '--no-emoji', '--ci'].includes(arg));
// DÃ©tecter l'option --detach
const detachMode = args.includes('--detach');
const filteredArgs = args.filter(arg => arg !== '--detach');
const cmd = filteredArgs[0];
function usage() {
    globalLogger.info(`Rome CLI
Usage:
  rome run <workspace> [-- cmd...]
  rome start                         # lance tous les workspaces connus (2 -> duo, 3 -> trio)
  rome duo  <A> "<cmdA>" <B> "<cmdB>"
  rome trio <A> "<cmdA>" <B> "<cmdB>" <C> "<cmdC>"
  rome fix   [target] [-- cmd...]    # alias: auto-cd + commande
  rome clean [workspace]             # nettoie node_modules verrouillÃ©s
  rome build [workspace]             # build tous les workspaces
  rome test  [workspace]             # test tous les workspaces
  rome lint  [workspace]             # lint tous les workspaces
  rome init                          # crÃ©e un fichier rome.json de configuration
  rome backup                        # sauvegarde la configuration actuelle
  rome restore [backup]              # restaure une sauvegarde (derniÃ¨re par dÃ©faut)
  rome army                          # affiche l'armÃ©e romaine (formations et unitÃ©s)
  rome preinstall                    # installe les dÃ©pendances de tous les workspaces

  rome ls                            # liste simple, indexÃ©e et triÃ©e des workspaces
  rome path <id|name>                # affiche le chemin absolu d'un workspace
  rome go <id|name> -- <cmd ...>     # exÃ©cute une commande dans un workspace
  rome code|explorer <id|name>       # ouvre VS Code / l'explorateur
  rome tunnel [up|down|status|test]  # gestion du tunnel avec tests intÃ©grÃ©s

  rome deploy [build]                # dÃ©ploiement Netlify (avec/sans build)
  rome cockpit                       # lance le cockpit multi-panels (dev complet)
  rome cf [up|down|quick]            # gestion des tunnels Cloudflare
  rome processes [stop]              # gestion des processus dÃ©tachÃ©s

Options d'affichage:
  --plain                            # sortie sobre (pas d'emojis, pas de roman)
  --json                             # sortie machine-readable pour CI
  --no-emoji                         # garde le texte fun mais sans emojis
  --ci                               # Ã©quivaut Ã  --plain --no-emoji

Options de processus:
  --detach                           # lance les processus en arriÃ¨re-plan (dÃ©tachÃ©s)
`);
}
async function main() {
    if (!cmd)
        return usage();
    if (cmd === "run") {
        const sep = args.indexOf("--");
        const ws = args[1];
        const command = sep >= 0 ? args.slice(sep + 1).join(" ") : undefined;
        if (!ws)
            return usage();
        return runOne(ws, command, outputOptions);
    }
    if (cmd === "start") {
        // lit les workspaces connus et lance 2 (duo) ou 3 (trio)
        const { resolveWorkspaces } = await import("./utils.js");
        const map = resolveWorkspaces();
        // RÃ©cupÃ¨re tous les alias uniques (basename des chemins)
        const aliases = new Set();
        for (const key of Object.keys(map)) {
            const alias = key.includes("/") ? key.split("/").pop() : key;
            if (alias && map[key]) {
                aliases.add(alias);
            }
        }
        const uniq = Array.from(aliases).filter(alias => map[alias]).slice(0, 3);
        globalLogger.info(`ğŸ” Workspaces dÃ©tectÃ©s: ${uniq.join(", ")}`);
        if (uniq.length === 0)
            return globalLogger.error("âŒ Rome: aucun workspace dÃ©tectÃ©.");
        if (uniq.length === 1)
            return runOne(uniq[0], "npm run dev");
        if (uniq.length === 2)
            return duo(uniq[0], "npm run dev", uniq[1], "npm run dev", outputOptions, detachMode);
        return trio(uniq[0], "npm run dev", uniq[1], "npm run dev", uniq[2], "npm run dev", outputOptions, detachMode);
    }
    // --- New: env command routing ---
    if (cmd === 'env') {
        try {
            const { envCommand } = await import('./env/cli.js');
            // Build a minimal argv-like object expected by envCommand
            const argv = { _: filteredArgs };
            // simple flag parsing for --profile and --out
            for (let i = 0; i < filteredArgs.length; i++) {
                const a = filteredArgs[i];
                if (a === '--profile' && filteredArgs[i + 1])
                    argv.profile = filteredArgs[i + 1];
                if (a === '--out' && filteredArgs[i + 1])
                    argv.out = filteredArgs[i + 1];
            }
            await envCommand(argv);
        }
        catch (e) {
            // Safely stringify unknown error types for TypeScript strict mode
            const msg = e instanceof Error ? e.message : String(e);
            globalLogger.error(`rome env: ${msg}`);
            process.exit(1);
        }
        return;
    }
    if (cmd === "duo") {
        const [, a, ca, b, cb] = filteredArgs;
        if (!a || !ca || !b || !cb)
            return usage();
        return duo(a, ca, b, cb, outputOptions, detachMode);
    }
    if (cmd === "trio") {
        const [, a, ca, b, cb, c, cc] = filteredArgs;
        if (!a || !ca || !b || !cb || !c || !cc)
            return usage();
        return trio(a, ca, b, cb, c, cc, outputOptions, detachMode);
    }
    if (cmd === "clean") {
        const { resolveWorkspaces, cleanNodeModules } = await import("./utils.js");
        const target = args[1];
        if (target) {
            const map = resolveWorkspaces();
            const wsPath = map[target];
            if (!wsPath)
                return globalLogger.error(`âŒ Workspace "${target}" non trouvÃ©.`);
            globalLogger.info(`ğŸ§¹ Nettoyage de ${wsPath}/node_modules...`);
            cleanNodeModules(wsPath);
            globalLogger.success("âœ… Nettoyage terminÃ©.");
        }
        else {
            // Nettoie tous les workspaces
            const map = resolveWorkspaces();
            const workspaces = Object.keys(map).filter(k => !k.includes("/"));
            if (workspaces.length === 0)
                return globalLogger.error("âŒ Aucun workspace dÃ©tectÃ©.");
            for (const ws of workspaces) {
                const wsPath = map[ws];
                globalLogger.info(`ğŸ§¹ Nettoyage de ${ws}/node_modules...`);
                cleanNodeModules(wsPath);
            }
            globalLogger.success("âœ… Nettoyage terminÃ© pour tous les workspaces.");
        }
        return;
    }
    if (cmd === "build") {
        const { resolveWorkspaces, detectPackageManager, getPackageCommand } = await import("./utils.js");
        const target = args[1];
        const pm = detectPackageManager();
        if (target) {
            const map = resolveWorkspaces();
            const wsPath = map[target];
            if (!wsPath)
                return globalLogger.error(`âŒ Workspace "${target}" non trouvÃ©.`);
            globalLogger.info(`ğŸ”¨ Build de ${target}...`);
            const { spawnLogged } = await import("./utils.js");
            const buildCmd = getPackageCommand(pm, 'build');
            const [buildCmdParsed, ...buildArgs] = buildCmd.split(/\s+/);
            spawnLogged(buildCmdParsed, buildArgs, wsPath, target);
        }
        else {
            // Build tous les workspaces
            const map = resolveWorkspaces();
            const workspaces = Object.keys(map).filter(k => !k.includes("/"));
            if (workspaces.length === 0)
                return globalLogger.error("âŒ Aucun workspace dÃ©tectÃ©.");
            globalLogger.info(`ğŸ”¨ Build de tous les workspaces: ${workspaces.join(", ")}`);
            for (const ws of workspaces) {
                const wsPath = map[ws];
                globalLogger.info(`ğŸ”¨ Build de ${ws}...`);
                const { spawnLogged } = await import("./utils.js");
                const buildCmd = getPackageCommand(pm, 'build');
                const [buildCmdParsed, ...buildArgs] = buildCmd.split(/\s+/);
                spawnLogged(buildCmdParsed, buildArgs, wsPath, ws);
            }
        }
        return;
    }
    if (cmd === "test") {
        const { resolveWorkspaces, detectPackageManager, getPackageCommand } = await import("./utils.js");
        const target = args[1];
        const pm = detectPackageManager();
        if (target) {
            const map = resolveWorkspaces();
            const wsPath = map[target];
            if (!wsPath)
                return globalLogger.error(`âŒ Workspace "${target}" non trouvÃ©.`);
            globalLogger.info(`ğŸ§ª Test de ${target}...`);
            const { spawnLogged } = await import("./utils.js");
            const testCmd = getPackageCommand(pm, 'test');
            const [testCmdParsed, ...testArgs] = testCmd.split(/\s+/);
            spawnLogged(testCmdParsed, testArgs, wsPath, target);
        }
        else {
            // Test tous les workspaces
            const map = resolveWorkspaces();
            const workspaces = Object.keys(map).filter(k => !k.includes("/"));
            if (workspaces.length === 0)
                return globalLogger.error("âŒ Aucun workspace dÃ©tectÃ©.");
            globalLogger.info(`ğŸ§ª Test de tous les workspaces: ${workspaces.join(", ")}`);
            for (const ws of workspaces) {
                const wsPath = map[ws];
                globalLogger.info(`ğŸ§ª Test de ${ws}...`);
                const { spawnLogged } = await import("./utils.js");
                const testCmd = getPackageCommand(pm, 'test');
                const [testCmdParsed, ...testArgs] = testCmd.split(/\s+/);
                spawnLogged(testCmdParsed, testArgs, wsPath, ws);
            }
        }
        return;
    }
    if (cmd === "lint") {
        const { resolveWorkspaces, detectPackageManager, getPackageCommand } = await import("./utils.js");
        const target = args[1];
        const pm = detectPackageManager();
        if (target) {
            const map = resolveWorkspaces();
            const wsPath = map[target];
            if (!wsPath)
                return globalLogger.error(`âŒ Workspace "${target}" non trouvÃ©.`);
            globalLogger.info(`ğŸ” Lint de ${target}...`);
            const { spawnLogged } = await import("./utils.js");
            const lintCmd = getPackageCommand(pm, 'lint');
            const [lintCmdParsed, ...lintArgs] = lintCmd.split(/\s+/);
            spawnLogged(lintCmdParsed, lintArgs, wsPath, target);
        }
        else {
            // Lint tous les workspaces
            const map = resolveWorkspaces();
            const workspaces = Object.keys(map).filter(k => !k.includes("/"));
            if (workspaces.length === 0)
                return globalLogger.error("âŒ Aucun workspace dÃ©tectÃ©.");
            globalLogger.info(`ğŸ” Lint de tous les workspaces: ${workspaces.join(", ")}`);
            for (const ws of workspaces) {
                const wsPath = map[ws];
                globalLogger.info(`ğŸ” Lint de ${ws}...`);
                const { spawnLogged } = await import("./utils.js");
                const lintCmd = getPackageCommand(pm, 'lint');
                const [lintCmdParsed, ...lintArgs] = lintCmd.split(/\s+/);
                spawnLogged(lintCmdParsed, lintArgs, wsPath, ws);
            }
        }
        return;
    }
    if (cmd === "init") {
        const fs = await import("fs");
        const path = await import("path");
        const configPath = path.join(process.cwd(), 'rome.json');
        if (fs.existsSync(configPath)) {
            globalLogger.warning('rome.json existe dÃ©jÃ . Voulez-vous le remplacer ? (y/N)');
            process.stdin.once('data', (data) => {
                if (data.toString().trim().toLowerCase() === 'y') {
                    createConfig();
                }
                else {
                    globalLogger.error('AnnulÃ©');
                }
                process.exit(0);
            });
            process.stdin.setRawMode(true);
            process.stdin.resume();
        }
        else {
            createConfig();
        }
        function createConfig() {
            const defaultConfig = {
                workspaces: {
                    patterns: [
                        "server", "backend", "api", "web", "front", "client", "app",
                        "apps/*", "packages/*", "services/*", "src/*"
                    ],
                    exclude: ["node_modules", ".git", "dist", "build"]
                },
                packageManager: "auto",
                scripts: {
                    build: "build",
                    test: "test",
                    lint: "lint",
                    dev: "dev"
                },
                processes: {
                    server: {
                        command: "npm run dev",
                        cwd: "apps/server",
                        detach: true,
                        restart: "always",
                        env: { "NODE_ENV": "development" }
                    },
                    web: {
                        command: "npm run dev",
                        cwd: "apps/web",
                        detach: true,
                        restart: "always"
                    },
                    tunnel: {
                        command: "cloudflared tunnel --url http://127.0.0.1:3000",
                        detach: true,
                        restart: "on-failure"
                    },
                    olloma: {
                        command: "olloma serve",
                        detach: true,
                        restart: "on-failure"
                    }
                },
                output: {
                    plain: false,
                    json: false,
                    noEmoji: false,
                    ci: false
                }
            };
            try {
                fs.writeFileSync(configPath, JSON.stringify(defaultConfig, null, 2));
                globalLogger.success('rome.json crÃ©Ã© avec succÃ¨s !');
                globalLogger.info('ğŸ’¡ Ã‰ditez ce fichier pour personnaliser la dÃ©tection des workspaces.');
            }
            catch (e) {
                globalLogger.error('Erreur lors de la crÃ©ation du fichier:', e);
            }
        }
        return;
    }
    if (cmd === "backup") {
        const fs = await import("fs");
        const path = await import("path");
        const configPath = path.join(process.cwd(), 'rome.json');
        if (!fs.existsSync(configPath)) {
            globalLogger.error('Aucun fichier rome.json trouvÃ© Ã  sauvegarder.');
            process.exit(1);
        }
        // GÃ©nÃ©rer un nom de backup avec timestamp
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
        const backupPath = path.join(process.cwd(), `rome.json.backup.${timestamp}`);
        try {
            const configContent = fs.readFileSync(configPath, 'utf8');
            fs.writeFileSync(backupPath, configContent, 'utf8');
            globalLogger.success(`Configuration sauvegardÃ©e : ${backupPath}`);
            // Lister les backups existants
            const files = fs.readdirSync(process.cwd());
            const backups = files.filter(f => f.startsWith('rome.json.backup.')).sort();
            if (backups.length > 1) {
                globalLogger.info(`ğŸ“ Backups existants (${backups.length}) :`);
                backups.forEach(backup => globalLogger.info(`   ${backup}`));
            }
        }
        catch (e) {
            globalLogger.error('Erreur lors de la sauvegarde:', e);
            process.exit(1);
        }
        return;
    }
    if (cmd === "restore") {
        const fs = await import("fs");
        const path = await import("path");
        const configPath = path.join(process.cwd(), 'rome.json');
        const files = fs.readdirSync(process.cwd());
        const backups = files.filter(f => f.startsWith('rome.json.backup.')).sort();
        if (backups.length === 0) {
            globalLogger.error('Aucune sauvegarde trouvÃ©e.');
            process.exit(1);
        }
        // Utiliser le backup spÃ©cifiÃ© ou le dernier
        const targetBackup = args[1] || backups[backups.length - 1];
        const backupPath = path.join(process.cwd(), targetBackup);
        if (!fs.existsSync(backupPath)) {
            globalLogger.error(`Sauvegarde "${targetBackup}" introuvable.`);
            globalLogger.info('ğŸ“ Sauvegardes disponibles :');
            backups.forEach(backup => globalLogger.info(`   ${backup}`));
            process.exit(1);
        }
        try {
            // Sauvegarder la config actuelle avant de restaurer
            if (fs.existsSync(configPath)) {
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                const autoBackupPath = path.join(process.cwd(), `rome.json.pre-restore.${timestamp}`);
                const currentContent = fs.readFileSync(configPath, 'utf8');
                fs.writeFileSync(autoBackupPath, currentContent, 'utf8');
                globalLogger.info(`ğŸ’¾ Config actuelle sauvegardÃ©e : ${autoBackupPath}`);
            }
            // Restaurer la sauvegarde
            const backupContent = fs.readFileSync(backupPath, 'utf8');
            fs.writeFileSync(configPath, backupContent, 'utf8');
            globalLogger.success(`Configuration restaurÃ©e depuis : ${targetBackup}`);
        }
        catch (e) {
            globalLogger.error('Erreur lors de la restauration:', e);
            process.exit(1);
        }
        return;
    }
    if (cmd === "army") {
        const { analyzeAllFormations } = await import("./utils.js");
        const formations = analyzeAllFormations();
        if (Object.keys(formations).length === 0) {
            globalLogger.error("Rome: aucune formation dÃ©tectÃ©e.");
            process.exit(1);
        }
        globalLogger.info("ğŸ›ï¸  ARMÃ‰E ROMAINE - Formations DÃ©tectÃ©es");
        globalLogger.info("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
        for (const [name, formation] of Object.entries(formations)) {
            const formationEmoji = {
                bataillon: "ğŸ°",
                legion: "âš”ï¸",
                armee: "ğŸ›ï¸"
            }[formation.type];
            const formationName = {
                bataillon: "Bataillon",
                legion: "LÃ©gion",
                armee: "ArmÃ©e"
            }[formation.type];
            globalLogger.info(`\n${formationEmoji} ${formationName} "${name}" (Force: ${formation.strength})`);
            globalLogger.info(`   ğŸ“ ${formation.path}`);
            // Compter les unitÃ©s par type
            const unitCounts = formation.units.reduce((acc, unit) => {
                acc[unit.type] = (acc[unit.type] || 0) + 1;
                return acc;
            }, {});
            const unitEmojis = {
                capitaine: "ğŸ‘¨â€âœˆï¸",
                archer: "ğŸ¹",
                catapulte: "ğŸ—ï¸",
                infanterie: "âš”ï¸",
                cavalerie: "ğŸ",
                centurion: "ğŸ‘‘",
                aquila: "ğŸ¦…",
                balliste: "ğŸ”«"
            };
            const unitNames = {
                capitaine: "Capitaines",
                archer: "Archers",
                catapulte: "Catapultes",
                infanterie: "Infanterie",
                cavalerie: "Cavalerie",
                centurion: "Centurions",
                aquila: "Aigles",
                balliste: "Ballistes"
            };
            for (const [unitType, count] of Object.entries(unitCounts)) {
                const emoji = unitEmojis[unitType] || "â“";
                const unitName = unitNames[unitType] || unitType;
                globalLogger.info(`   ${emoji} ${count} ${unitName}`);
            }
        }
        globalLogger.info("\nğŸ›ï¸  Fin de l'inspection des troupes");
        return;
    }
    if (cmd === "preinstall") {
        const { resolveWorkspaces, preInstallAllDeps } = await import("./utils.js");
        const workspaces = resolveWorkspaces();
        if (Object.keys(workspaces).length === 0) {
            globalLogger.error("Aucun workspace dÃ©tectÃ©.");
            process.exit(1);
        }
        await preInstallAllDeps(workspaces, globalLogger);
        return;
    }
    if (cmd === "ls") {
        const { indexer } = await import("./simple.js");
        const workspaces = await indexer.list();
        if (workspaces.length === 0) {
            globalLogger.error("Aucun workspace dÃ©tectÃ©.");
            process.exit(1);
        }
        globalLogger.info("ğŸ“‹ Workspaces IndexÃ©s");
        globalLogger.info("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
        const typeEmojis = {
            frontend: "ğŸŒ",
            backend: "âš™ï¸",
            api: "ğŸ”Œ",
            service: "ğŸ”§",
            shared: "ğŸ“š",
            other: "ğŸ“"
        };
        for (const ws of workspaces) {
            const emoji = typeEmojis[ws.type] || "ğŸ“";
            globalLogger.info(`${ws.id} ${ws.alias} ${emoji} ${ws.name}`);
            globalLogger.info(`   ğŸ“ ${ws.path}`);
        }
        globalLogger.info(`\nğŸ“Š Total: ${workspaces.length} workspace(s)`);
        return;
    }
    if (cmd === "path") {
        const { indexer } = await import("./simple.js");
        const identifier = args[1];
        if (!identifier) {
            globalLogger.error("Usage: rome path <id|name>");
            process.exit(1);
        }
        const workspace = await indexer.find(identifier);
        if (!workspace) {
            globalLogger.error(`Workspace "${identifier}" non trouvÃ©.`);
            globalLogger.info("Utilisez 'rome ls' pour voir les workspaces disponibles.");
            process.exit(1);
        }
        // Just output the path (for scripting)
        console.log(workspace.path);
        return;
    }
    if (cmd === "go") {
        const { indexer } = await import("./simple.js");
        const sep = args.indexOf("--");
        const identifier = args[1];
        const command = sep >= 0 ? args.slice(sep + 1).join(" ") : undefined;
        if (!identifier || !command) {
            globalLogger.error("Usage: rome go <id|name> -- <command>");
            process.exit(1);
        }
        const workspace = await indexer.find(identifier);
        if (!workspace) {
            globalLogger.error(`Workspace "${identifier}" non trouvÃ©.`);
            globalLogger.info("Utilisez 'rome ls' pour voir les workspaces disponibles.");
            process.exit(1);
        }
        globalLogger.info(`ğŸš€ ExÃ©cution dans ${workspace.name} (${workspace.alias}): ${command}`);
        const { spawnLogged } = await import("./utils.js");
        const [cmdParsed, ...cmdArgs] = command.split(/\s+/);
        spawnLogged(cmdParsed, cmdArgs, workspace.path, workspace.name);
        return;
    }
    if (cmd === "code" || cmd === "explorer") {
        const { indexer } = await import("./simple.js");
        const identifier = args[1];
        if (!identifier) {
            globalLogger.error(`Usage: rome ${cmd} <id|name>`);
            process.exit(1);
        }
        const workspace = await indexer.find(identifier);
        if (!workspace) {
            globalLogger.error(`Workspace "${identifier}" non trouvÃ©.`);
            globalLogger.info("Utilisez 'rome ls' pour voir les workspaces disponibles.");
            process.exit(1);
        }
        if (cmd === "code") {
            globalLogger.info(`ğŸ’» Ouverture de ${workspace.name} dans VS Code...`);
            const { spawn } = await import("child_process");
            spawn("code", [workspace.path], { stdio: "inherit" });
        }
        else {
            globalLogger.info(`ğŸ“‚ Ouverture de ${workspace.name} dans l'explorateur...`);
            const { spawn } = await import("child_process");
            if (process.platform === "win32") {
                spawn("explorer", [workspace.path], { stdio: "inherit" });
            }
            else if (process.platform === "darwin") {
                spawn("open", [workspace.path], { stdio: "inherit" });
            }
            else {
                spawn("xdg-open", [workspace.path], { stdio: "inherit" });
            }
        }
        return;
    }
    if (cmd === "tunnel") {
        const { tunnelManager } = await import("./tunnel.js");
        const subCmd = args[1];
        if (!subCmd) {
            globalLogger.info("Rome Tunnel - Gestion des tunnels");
            globalLogger.info("Usage:");
            globalLogger.info("  rome tunnel up [port]     # DÃ©marre le tunnel");
            globalLogger.info("  rome tunnel down          # ArrÃªte le tunnel");
            globalLogger.info("  rome tunnel status        # Affiche le statut");
            globalLogger.info("  rome tunnel test          # Teste la connectivitÃ©");
            globalLogger.info("  rome tunnel split         # Lance terminal split");
            globalLogger.info("  rome tunnel auto          # Lanceur automatique");
            return;
        }
        try {
            switch (subCmd) {
                case "up": {
                    const port = args[2] ? parseInt(args[2]) : 3000;
                    if (isNaN(port)) {
                        globalLogger.error("Port invalide");
                        process.exit(1);
                    }
                    // Configurer l'instance globale avec le port spÃ©cifiÃ©
                    tunnelManager.setPort(port);
                    globalLogger.info(`ğŸŒ DÃ©marrage du tunnel sur le port ${port}...`);
                    const status = await tunnelManager.start();
                    globalLogger.success(`âœ… Tunnel actif: ${status.url}`);
                    break;
                }
                case "down": {
                    globalLogger.info("ğŸ›‘ ArrÃªt du tunnel...");
                    await tunnelManager.stop();
                    globalLogger.success("âœ… Tunnel arrÃªtÃ©");
                    break;
                }
                case "status": {
                    globalLogger.info("ğŸ“Š VÃ©rification du statut...");
                    const status = await tunnelManager.checkStatus();
                    if (status.isRunning) {
                        globalLogger.success(`âœ… Tunnel actif: ${status.url}`);
                        globalLogger.info(`ğŸ”Œ Port local: ${status.port}`);
                        globalLogger.info(`ğŸ•’ DerniÃ¨re vÃ©rification: ${status.lastChecked.toLocaleTimeString()}`);
                    }
                    else {
                        globalLogger.warning("âŒ Aucun tunnel actif");
                    }
                    break;
                }
                case "test": {
                    globalLogger.info("ğŸ§ª Tests de connectivitÃ©...");
                    const tests = await tunnelManager.runTests();
                    if (tests.connectivity) {
                        globalLogger.success("âœ… ConnectivitÃ© OK");
                    }
                    else {
                        globalLogger.error("âŒ Erreur de connectivitÃ©");
                    }
                    globalLogger.info("ğŸ“‹ Tests des endpoints:");
                    for (const endpoint of tests.endpoints) {
                        if (endpoint.success) {
                            globalLogger.success(`âœ… ${endpoint.url} - Status: ${endpoint.statusCode}`);
                        }
                        else {
                            globalLogger.error(`âŒ ${endpoint.url} - Ã‰chec`);
                        }
                    }
                    break;
                }
                case "split": {
                    globalLogger.info("ğŸ–¥ï¸ Lancement du terminal split...");
                    await tunnelManager.launchSplitTerminal();
                    globalLogger.success("âœ… Terminal split lancÃ©");
                    break;
                }
                case "auto": {
                    globalLogger.info("ğŸš€ Lancement du mode automatique...");
                    await tunnelManager.launchAutoLauncher();
                    globalLogger.success("âœ… Lanceur automatique dÃ©marrÃ©");
                    break;
                }
                default: {
                    globalLogger.error(`Sous-commande inconnue: ${subCmd}`);
                    globalLogger.info("Utilisez 'rome tunnel' pour voir les options disponibles.");
                    process.exit(1);
                }
            }
        }
        catch (error) {
            globalLogger.error(`Erreur tunnel: ${error}`);
            process.exit(1);
        }
        return;
    }
    if (cmd === "deploy") {
        const subCmd = args[1];
        const { spawnLogged } = await import("./utils.js");
        if (subCmd === "build") {
            globalLogger.info("ğŸ”¨ Build + dÃ©ploiement Netlify...");
            // Build d'abord
            const buildCmd = "npm run web:build";
            const [buildCmdParsed, ...buildArgs] = buildCmd.split(/\s+/);
            spawnLogged(buildCmdParsed, buildArgs, process.cwd(), "build");
            // Puis dÃ©ploiement
            const deployCmd = "npx netlify deploy --prod --dir=apps/web/dist --functions=netlify/functions";
            const [deployCmdParsed, ...deployArgs] = deployCmd.split(/\s+/);
            spawnLogged(deployCmdParsed, deployArgs, process.cwd(), "deploy");
        }
        else {
            globalLogger.info("ğŸš€ DÃ©ploiement Netlify (build existant)...");
            const deployCmd = "npx netlify deploy --prod --dir=apps/web/dist --functions=netlify/functions";
            const [deployCmdParsed, ...deployArgs] = deployCmd.split(/\s+/);
            spawnLogged(deployCmdParsed, deployArgs, process.cwd(), "deploy");
        }
        return;
    }
    if (cmd === "cockpit") {
        globalLogger.info("ğŸš€ Lancement du Cockpit Rome (multi-panels)...");
        const { spawn } = await import("child_process");
        const path = await import("path");
        const fs = await import("fs");
        // Chemins des workspaces
        const serverPath = path.join(process.cwd(), "apps", "server");
        const webPath = path.join(process.cwd(), "apps", "web");
        // Configuration des processus depuis rome.json si disponible
        const configPath = path.join(process.cwd(), 'rome.json');
        let processes = {};
        if (fs.existsSync(configPath)) {
            try {
                const config = JSON.parse(fs.readFileSync(configPath, 'utf8'));
                processes = config.processes || {};
            }
            catch (e) {
                // Ignore les erreurs de parsing
            }
        }
        // Fonction pour lancer un processus dÃ©tachÃ© avec gestion robuste
        const launchDetached = async (name, command, cwd, env) => {
            const [cmd, ...args] = command.split(/\s+/);
            const options = {
                stdio: "pipe", // Ne pas hÃ©riter pour Ã©viter les interruptions
                detached: true,
                env: { ...process.env, ...env }
            };
            if (cwd)
                options.cwd = cwd;
            const child = spawn(cmd, args, options);
            // Logs sÃ©parÃ©s pour chaque processus
            const logFile = path.join(process.cwd(), `logs`, `${name}.log`);
            const fs = await import("fs");
            if (!fs.existsSync(path.join(process.cwd(), "logs"))) {
                fs.mkdirSync(path.join(process.cwd(), "logs"));
            }
            const logStream = fs.createWriteStream(logFile, { flags: 'a' });
            child.stdout?.pipe(logStream);
            child.stderr?.pipe(logStream);
            child.on("exit", (code) => {
                const status = code === 0 ? "âœ…" : "âŒ";
                globalLogger.info(`${status} Processus ${name} terminÃ© (code: ${code})`);
            });
            // RedÃ©marrage automatique si configurÃ©
            if (processes[name]?.restart === "always") {
                child.on("exit", (code) => {
                    if (code !== 0) {
                        globalLogger.warning(`ğŸ”„ RedÃ©marrage automatique de ${name}...`);
                        setTimeout(async () => await launchDetached(name, command, cwd, env), 2000);
                    }
                });
            }
            return child;
        };
        // Lancer les processus configurÃ©s ou par dÃ©faut
        if (Object.keys(processes).length > 0) {
            // Utiliser la configuration personnalisÃ©e
            for (const [name, proc] of Object.entries(processes)) {
                if (proc.command) {
                    const cwd = proc.cwd ? path.resolve(proc.cwd) : undefined;
                    await launchDetached(name, proc.command, cwd, proc.env);
                    globalLogger.info(`ğŸš€ ${name}: ${proc.command}`);
                }
            }
        }
        else {
            // Configuration par dÃ©faut
            await launchDetached("server", "npm run dev", serverPath);
            await launchDetached("ollima", "ollima serve");
            await launchDetached("tunnel", "cloudflared tunnel --url http://127.0.0.1:3000");
            await launchDetached("web", "npm run dev", webPath);
            globalLogger.info("ğŸš€ Services par dÃ©faut lancÃ©s:");
            globalLogger.info("  ğŸ”§ server: npm run dev");
            globalLogger.info("  ğŸ§  ollima: ollima serve");
            globalLogger.info("  ï¿½ï¸  tunnel: cloudflared tunnel");
            globalLogger.info("  ğŸŒ web: npm run dev");
        }
        globalLogger.success("âœ… Cockpit lancÃ© ! Processus dÃ©tachÃ©s en arriÃ¨re-plan.");
        globalLogger.info("ğŸ“ Logs disponibles dans le dossier ./logs/");
        globalLogger.info("ğŸ›‘ Utilisez Ctrl+C pour arrÃªter tous les processus");
        return;
    }
    if (cmd === "cf" || cmd === "cloudflare") {
        const subCmd = filteredArgs[1];
        const { spawnLogged } = await import("./utils.js");
        const { spawn } = await import("child_process");
        const path = await import("path");
        if (!subCmd) {
            globalLogger.info("Rome Cloudflare - Gestion des tunnels");
            globalLogger.info("Usage:");
            globalLogger.info("  rome cf up [port]        # Tunnel nommÃ© (stable)");
            globalLogger.info("  rome cf quick [port]     # Tunnel rapide (Ã©phÃ©mÃ¨re)");
            globalLogger.info("  rome cf down             # ArrÃªter tous les tunnels");
            globalLogger.info("");
            globalLogger.info("Options:");
            globalLogger.info("  --detach                 # Lancer en arriÃ¨re-plan");
            return;
        }
        const port = filteredArgs[2] ? parseInt(filteredArgs[2]) : 3000;
        if (isNaN(port)) {
            globalLogger.error("Port invalide");
            process.exit(1);
        }
        // Fonction pour lancer un tunnel dÃ©tachÃ©
        const launchDetachedTunnel = async (name, command) => {
            const [cmd, ...args] = command.split(/\s+/);
            const options = {
                stdio: "pipe", // Ne pas hÃ©riter pour Ã©viter les interruptions
                detached: true,
                env: process.env
            };
            const child = spawn(cmd, args, options);
            // Logs sÃ©parÃ©s pour chaque processus
            const logFile = path.join(process.cwd(), `logs`, `${name}.log`);
            const fs = await import("fs");
            if (!fs.existsSync(path.join(process.cwd(), "logs"))) {
                fs.mkdirSync(path.join(process.cwd(), "logs"));
            }
            const logStream = fs.createWriteStream(logFile, { flags: 'a' });
            child.stdout?.pipe(logStream);
            child.stderr?.pipe(logStream);
            child.on("exit", (code) => {
                const status = code === 0 ? "âœ…" : "âŒ";
                globalLogger.info(`${status} Tunnel ${name} terminÃ© (code: ${code})`);
            });
            return child;
        };
        try {
            switch (subCmd) {
                case "up": {
                    globalLogger.info(`ğŸŒ©ï¸ DÃ©marrage du tunnel Cloudflare nommÃ© sur le port ${port}...`);
                    // VÃ©rifier si cloudflared est installÃ©
                    const checkCmd = "cloudflared version";
                    const [checkCmdParsed, ...checkArgs] = checkCmd.split(/\s+/);
                    try {
                        spawnLogged(checkCmdParsed, checkArgs, process.cwd(), "check-cloudflared");
                    }
                    catch (e) {
                        globalLogger.error("âŒ cloudflared n'est pas installÃ©.");
                        globalLogger.info("ğŸ’¡ Installez-le avec: winget install Cloudflare.cloudflared");
                        process.exit(1);
                    }
                    // DÃ©marrer le tunnel nommÃ©
                    const tunnelCmd = `cloudflared tunnel run a11-local`;
                    if (detachMode) {
                        // Mode dÃ©tachÃ©
                        await launchDetachedTunnel("cloudflare-tunnel", tunnelCmd);
                        globalLogger.success(`âœ… Tunnel nommÃ© lancÃ© en arriÃ¨re-plan`);
                        globalLogger.info(`ğŸ“ Logs disponibles dans ./logs/cloudflare-tunnel.log`);
                    }
                    else {
                        // Mode normal
                        const [tunnelCmdParsed, ...tunnelArgs] = tunnelCmd.split(/\s+/);
                        spawnLogged(tunnelCmdParsed, tunnelArgs, process.cwd(), "cloudflare-tunnel");
                    }
                    break;
                }
                case "quick": {
                    globalLogger.info(`âš¡ DÃ©marrage du tunnel Cloudflare rapide sur le port ${port}...`);
                    const quickCmd = `cloudflared tunnel --url http://127.0.0.1:${port}`;
                    if (detachMode) {
                        // Mode dÃ©tachÃ©
                        await launchDetachedTunnel("cloudflare-quick", quickCmd);
                        globalLogger.success(`âœ… Tunnel rapide lancÃ© en arriÃ¨re-plan`);
                        globalLogger.info(`ğŸ“ Logs disponibles dans ./logs/cloudflare-quick.log`);
                    }
                    else {
                        // Mode normal
                        const [quickCmdParsed, ...quickArgs] = quickCmd.split(/\s+/);
                        spawnLogged(quickCmdParsed, quickArgs, process.cwd(), "cloudflare-quick");
                    }
                    break;
                }
                case "down": {
                    globalLogger.info("ğŸ›‘ ArrÃªt de tous les tunnels Cloudflare...");
                    // Tuer les processus cloudflared
                    const { spawn } = await import("child_process");
                    if (process.platform === "win32") {
                        spawn("taskkill", ["/F", "/IM", "cloudflared.exe"], { stdio: "inherit" });
                    }
                    else {
                        spawn("pkill", ["-f", "cloudflared"], { stdio: "inherit" });
                    }
                    globalLogger.success("âœ… Tunnels arrÃªtÃ©s");
                    break;
                }
                default: {
                    globalLogger.error(`Sous-commande inconnue: ${subCmd}`);
                    globalLogger.info("Utilisez 'rome cf' pour voir les options disponibles.");
                    process.exit(1);
                }
            }
        }
        catch (error) {
            globalLogger.error(`Erreur Cloudflare: ${error}`);
            process.exit(1);
        }
        return;
    }
    if (cmd === "processes") {
        const subCmd = filteredArgs[1];
        const { spawn } = await import("child_process");
        if (!subCmd || subCmd === "list") {
            globalLogger.info("ğŸ“Š Processus Rome actifs:");
            if (process.platform === "win32") {
                // Windows: utiliser tasklist
                const child = spawn("powershell", ["-Command", "Get-Process | Where-Object { $_.ProcessName -like '*node*' -or $_.ProcessName -like '*ollama*' -or $_.ProcessName -like '*cloudflared*' } | Select-Object ProcessName, Id, CPU, WorkingSet | Format-Table"], {
                    stdio: "inherit"
                });
            }
            else {
                // Unix: utiliser ps
                const child = spawn("ps", ["aux", "|", "grep", "-E", "(node|ollama|cloudflared)"], {
                    stdio: "inherit"
                });
            }
            return;
        }
        if (subCmd === "stop") {
            globalLogger.info("ğŸ›‘ ArrÃªt de tous les processus Rome...");
            if (process.platform === "win32") {
                // Windows: tuer les processus spÃ©cifiques
                const processes = ["node.exe", "ollama.exe", "cloudflared.exe"];
                for (const proc of processes) {
                    spawn("taskkill", ["/F", "/IM", proc], { stdio: "inherit" });
                }
            }
            else {
                // Unix: utiliser pkill
                spawn("pkill", ["-f", "node|ollama|cloudflared"], { stdio: "inherit" });
            }
            globalLogger.success("âœ… Processus arrÃªtÃ©s");
            return;
        }
        globalLogger.error(`Sous-commande inconnue: ${subCmd}`);
        globalLogger.info("Utilisez 'rome processes list' ou 'rome processes stop'");
        return;
    }
    return usage();
}
main().catch(e => { globalLogger.error("Rome:", e); process.exit(1); });
