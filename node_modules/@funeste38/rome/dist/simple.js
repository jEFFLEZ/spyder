/** Classe pour gérer l'indexation simplifiée des workspaces */
export class SimpleIndexer {
    workspaces = [];
    indexMap = new Map();
    initialized = false;
    constructor() {
        // L'initialisation sera faite de manière lazy
    }
    /** Initialise l'index si nécessaire */
    async ensureInitialized() {
        if (!this.initialized) {
            await this.indexWorkspaces();
            this.initialized = true;
        }
    }
    /** Indexe tous les workspaces détectés */
    async indexWorkspaces() {
        // Import dynamique pour éviter les dépendances circulaires
        const { resolveWorkspaces } = await import("./utils.js");
        const map = resolveWorkspaces();
        // Convertir en array et trier
        const entries = Object.entries(map).map(([name, wsPath]) => ({
            name,
            path: wsPath,
            // Détecter le type basé sur le nom/chemin
            type: this.detectType(name, wsPath),
            // Priorité pour le tri (frontend > backend > shared > other)
            priority: this.getPriority(name, wsPath)
        }));
        // Trier par priorité puis par nom
        entries.sort((a, b) => {
            if (a.priority !== b.priority)
                return a.priority - b.priority;
            return a.name.localeCompare(b.name);
        });
        // Créer les IDs et alias
        this.workspaces = entries.map((entry, index) => {
            const id = `#${index + 1}`;
            const alias = this.generateAlias(entry.type, index + 1);
            const workspace = {
                id,
                alias,
                name: entry.name,
                path: entry.path,
                type: entry.type,
                priority: entry.priority
            };
            // Indexer par id, alias, et nom
            this.indexMap.set(id, workspace);
            this.indexMap.set(alias, workspace);
            this.indexMap.set(entry.name, workspace);
            return workspace;
        });
    }
    /** Détecte le type de workspace basé sur le nom/chemin */
    detectType(name, wsPath) {
        const lowerName = name.toLowerCase();
        const lowerPath = wsPath.toLowerCase();
        // Frontend
        if (lowerName.includes('front') || lowerName.includes('web') || lowerName.includes('client') ||
            lowerName.startsWith('f') || lowerPath.includes('front') || lowerPath.includes('web')) {
            return 'frontend';
        }
        // Backend
        if (lowerName.includes('back') || lowerName.includes('server') || lowerName.includes('api') ||
            lowerName.startsWith('b') || lowerPath.includes('back') || lowerPath.includes('server')) {
            return 'backend';
        }
        // API/Service
        if (lowerName.includes('api') || lowerName.includes('service') || lowerName.startsWith('s')) {
            return 'service';
        }
        // Shared
        if (lowerName.includes('shared') || lowerName.includes('common') || lowerName.includes('lib') ||
            lowerName.startsWith('l')) {
            return 'shared';
        }
        return 'other';
    }
    /** Calcule la priorité pour le tri */
    getPriority(name, wsPath) {
        const type = this.detectType(name, wsPath);
        const priorities = {
            frontend: 1,
            backend: 2,
            api: 3,
            service: 3,
            shared: 4,
            other: 5
        };
        return priorities[type] || 5;
    }
    /** Génère un alias court basé sur le type */
    generateAlias(type, index) {
        const prefixes = {
            frontend: 'f',
            backend: 'b',
            api: 'a',
            service: 's',
            shared: 'l', // lib
            other: 'o'
        };
        return `${prefixes[type]}${index}`;
    }
    /** Liste tous les workspaces indexés */
    async list() {
        await this.ensureInitialized();
        return [...this.workspaces];
    }
    /** Trouve un workspace par id, alias, ou nom */
    async find(identifier) {
        await this.ensureInitialized();
        return this.indexMap.get(identifier) || null;
    }
    /** Recherche floue par nom */
    async search(query) {
        await this.ensureInitialized();
        const lowerQuery = query.toLowerCase();
        return this.workspaces.filter(ws => ws.name.toLowerCase().includes(lowerQuery) ||
            ws.alias.toLowerCase().includes(lowerQuery) ||
            ws.type.toLowerCase().includes(lowerQuery));
    }
}
// Instance globale
export const indexer = new SimpleIndexer();
