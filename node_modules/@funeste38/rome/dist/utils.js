import fs from "fs";
import path from "path";
import { spawn, spawnSync } from "child_process";
import { globalLogger } from "./logger.js";
export function isPowerShell() {
    return !!process.env.PSModulePath && process.platform === "win32";
}
export function ensureNodeOptionsNoDeprecation() {
    if (!process.env.NODE_OPTIONS?.includes("--no-deprecation")) {
        process.env.NODE_OPTIONS = [process.env.NODE_OPTIONS, "--no-deprecation"].filter(Boolean).join(" ").trim();
    }
}
/** DÃ©tecte le gestionnaire de paquets utilisÃ© */
export function detectPackageManager(cwd = process.cwd()) {
    if (fs.existsSync(path.join(cwd, 'yarn.lock')))
        return 'yarn';
    if (fs.existsSync(path.join(cwd, 'pnpm-lock.yaml')))
        return 'pnpm';
    return 'npm'; // dÃ©faut
}
/** Commandes Ã©quivalentes selon le gestionnaire */
export function getPackageCommand(pm, script) {
    switch (pm) {
        case 'yarn': return script === 'install' ? 'yarn' : `yarn ${script}`;
        case 'pnpm': return script === 'install' ? 'pnpm install' : `pnpm ${script}`;
        default: return script === 'install' ? 'npm install' : `npm run ${script}`;
    }
}
/** Nettoie les node_modules verrouillÃ©s (utile sur Windows) */
export function cleanNodeModules(dir) {
    const nm = path.join(dir, "node_modules");
    if (!fs.existsSync(nm))
        return;
    try {
        if (process.platform === "win32") {
            // Sur Windows, utilise rmdir /s/q pour forcer
            spawnSync("cmd", ["/c", "rmdir", "/s", "/q", nm], { stdio: "inherit" });
        }
        else {
            // Sur Unix, utilise rm -rf
            spawnSync("rm", ["-rf", nm], { stdio: "inherit" });
        }
    }
    catch (e) {
        globalLogger.warning(`Impossible de nettoyer ${nm}:`, e);
    }
}
export function readRootPackage(root = process.cwd()) {
    const p = path.join(root, "package.json");
    if (!fs.existsSync(p))
        return null;
    try {
        return JSON.parse(fs.readFileSync(p, "utf8"));
    }
    catch {
        return null;
    }
}
/** RÃ©sout les workspaces en { alias -> chemin } avec dÃ©duplication par realpath */
export function resolveWorkspaces(root = process.cwd()) {
    const pkg = readRootPackage(root);
    const map = {};
    const seenPaths = new Set(); // Pour dÃ©duplication par realpath
    const patterns = (pkg?.workspaces && Array.isArray(pkg.workspaces) ? pkg.workspaces :
        pkg?.workspaces?.packages && Array.isArray(pkg.workspaces.packages) ? pkg.workspaces.packages : []);
    // Liste Ã©tendue de candidats courants
    const candidates = new Set([
        ...patterns,
        // Dossiers Ã  la racine
        "server", "backend", "api", "web", "front", "client", "app",
        // Dossiers dans apps/
        "apps/server", "apps/backend", "apps/api", "apps/web", "apps/front", "apps/client", "apps/app",
        // Dossiers dans packages/
        "packages/server", "packages/backend", "packages/api", "packages/web", "packages/front", "packages/client", "packages/app",
        // Autres patterns courants
        "pool-front", "pool-server", "services/server", "services/web", "src/server", "src/web"
    ]);
    // Fonction helper pour ajouter un workspace avec dÃ©duplication
    const addWorkspace = (alias, absPath) => {
        try {
            const realPath = fs.realpathSync(absPath);
            if (!seenPaths.has(realPath) && fs.existsSync(path.join(realPath, "package.json"))) {
                seenPaths.add(realPath);
                map[alias] = realPath;
            }
        }
        catch (e) {
            // Ignore les erreurs de rÃ©solution de chemin
        }
    };
    for (const rel of candidates) {
        const abs = path.join(root, rel);
        const alias = path.basename(rel);
        addWorkspace(alias, abs);
    }
    // Recherche rÃ©cursive dans les sous-dossiers courants
    const commonDirs = ["apps", "packages", "services", "src"];
    for (const dir of commonDirs) {
        const dirPath = path.join(root, dir);
        if (fs.existsSync(dirPath) && fs.statSync(dirPath).isDirectory()) {
            try {
                const entries = fs.readdirSync(dirPath);
                for (const entry of entries) {
                    const fullPath = path.join(dirPath, entry);
                    const alias = entry;
                    addWorkspace(alias, fullPath);
                }
            }
            catch (e) {
                // Ignore les erreurs de lecture
            }
        }
    }
    return map;
}
export function prefix(tag, b) {
    const lines = b.toString().split(/\r?\n/);
    return lines.map((l, i) => (l.length || i < lines.length - 1) ? `[${tag}] ${l}\n` : "").join("");
}
/** Spawn sÃ©curisÃ© avec gestion des args et buffer */
export function spawnLogged(cmd, args, cwd, tag) {
    const isPowershell = isPowerShell();
    const opts = {
        cwd,
        env: process.env,
        stdio: ["inherit", "pipe", "pipe"],
        // Ã‰vite shell: true pour les problÃ¨mes de quoting
        shell: false
    };
    let child;
    if (isPowershell) {
        // Sous PowerShell, utilise cmd.exe comme wrapper pour Ã©viter les problÃ¨mes de quoting
        child = spawn("cmd.exe", ["/c", cmd, ...args], opts);
    }
    else {
        // Sur Unix, spawn direct
        child = spawn(cmd, args, opts);
    }
    child.stdout?.on("data", (b) => process.stdout.write(prefix(tag, b)));
    child.stderr?.on("data", (b) => process.stderr.write(prefix(tag, b)));
    child.on("exit", (code) => globalLogger.info(`exit ${code ?? 0}`));
    child.on("error", (err) => globalLogger.error(`error: ${err.message}`));
    return child;
}
/** DÃ©termine la commande d'installation optimale */
export function getInstallCommand(cwd) {
    const pm = detectPackageManager(cwd);
    const hasLockFile = pm === 'npm' ? fs.existsSync(path.join(cwd, 'package-lock.json')) :
        pm === 'yarn' ? fs.existsSync(path.join(cwd, 'yarn.lock')) :
            fs.existsSync(path.join(cwd, 'pnpm-lock.yaml'));
    if (hasLockFile && pm === 'npm') {
        return { cmd: 'npm', args: ['ci'] }; // npm ci pour installations dÃ©terministes
    }
    // Commandes d'installation standards
    switch (pm) {
        case 'yarn': return { cmd: 'yarn', args: ['install'] };
        case 'pnpm': return { cmd: 'pnpm', args: ['install'] };
        default: return { cmd: 'npm', args: ['install'] };
    }
}
/** Essaie d'installer les dÃ©pendances automatiquement */
export function tryInstallDeps(cwd, tag, logger) {
    const log = logger || globalLogger;
    return new Promise((resolve) => {
        log.info(`ðŸ”„ Installation des dÃ©pendances...`);
        const { cmd, args } = getInstallCommand(cwd);
        const child = spawnLogged(cmd, args, cwd, tag);
        let hasErrors = false;
        let stderrOutput = '';
        child.stderr?.on("data", (data) => {
            stderrOutput += data.toString();
            // ConsidÃ©rer comme erreur seulement si ce n'est pas juste des warnings npm
            if (!data.toString().includes('npm warn') && !data.toString().includes('warn')) {
                hasErrors = true;
            }
        });
        child.on("exit", (code) => {
            if (code === 0 && !hasErrors) {
                log.success(`âœ… DÃ©pendances installÃ©es`);
                resolve(true);
            }
            else {
                log.error(`âŒ Ã‰chec installation (code ${code})`);
                resolve(false);
            }
        });
        // Timeout aprÃ¨s 60 secondes (plus long pour npm ci)
        setTimeout(() => {
            if (!child.killed) {
                log.warning(`â° Timeout installation, arrÃªt forcÃ©`);
                try {
                    // Tue le processus et ses enfants
                    if (process.platform === 'win32') {
                        spawn('taskkill', ['/pid', child.pid.toString(), '/t', '/f'], { stdio: 'inherit' });
                    }
                    else {
                        child.kill('SIGKILL');
                    }
                }
                catch (e) {
                    log.warning(`âš ï¸ Impossible de tuer le processus:`, e);
                }
                resolve(false);
            }
        }, 60000);
    });
}
/** Tue proprement un processus et ses enfants */
export function killProcessTree(child) {
    if (!child || !child.pid)
        return;
    try {
        if (process.platform === 'win32') {
            // Sur Windows, utilise taskkill pour tuer l'arbre complet
            spawn('taskkill', ['/pid', child.pid.toString(), '/t', '/f'], { stdio: 'inherit' });
        }
        else {
            // Sur Unix, SIGKILL pour tuer l'arbre
            process.kill(-child.pid, 'SIGKILL');
        }
    }
    catch (e) {
        // Fallback: tue juste le processus parent
        try {
            child.kill('SIGKILL');
        }
        catch { }
    }
}
export function exitAll(children) {
    for (const c of children) {
        killProcessTree(c);
    }
}
/** Installation sÃ©quentielle des dÃ©pendances pour tous les workspaces */
export async function preInstallAllDeps(workspaces, logger) {
    const log = logger || globalLogger;
    const wsList = Object.entries(workspaces);
    if (wsList.length === 0)
        return;
    log.info(`ðŸ”„ PrÃ©-installation sÃ©quentielle pour ${wsList.length} workspace(s)...`);
    for (const [name, wsPath] of wsList) {
        log.info(`ðŸ“¦ Installation dans ${name}...`);
        const success = await tryInstallDeps(wsPath, name, log);
        if (!success) {
            log.warning(`âš ï¸ Ã‰chec installation dans ${name}, poursuite...`);
        }
        // Petite pause entre les installations pour Ã©viter les conflits
        await new Promise(resolve => setTimeout(resolve, 500));
    }
    log.success(`âœ… PrÃ©-installation terminÃ©e`);
}
/** Classifie un fichier selon la hiÃ©rarchie militaire romaine */
export function classifyFile(filePath, fileName) {
    const ext = path.extname(fileName).toLowerCase();
    const baseName = path.basename(fileName, ext);
    // Aquila - Ã‰tendards (fichiers de configuration principaux)
    if (fileName === 'package.json' || fileName === 'rome.json') {
        return { type: 'aquila', name: baseName, path: filePath, role: 'Ã‰tendard - Configuration principale' };
    }
    // Centurion - Officiers (fichiers de config)
    if (['tsconfig.json', 'eslint.config.js', 'vite.config.ts', 'webpack.config.js', 'babel.config.js'].includes(fileName) ||
        ext === '.config.js' || ext === '.config.ts' || ext === '.config.json') {
        return { type: 'centurion', name: baseName, path: filePath, role: 'Centurion - Configuration' };
    }
    // Catapulte - Artillerie (scripts et build)
    if (['package.json', 'Makefile', 'Dockerfile', 'docker-compose.yml'].includes(fileName) ||
        ext === '.sh' || ext === '.ps1' || ext === '.bat' ||
        fileName.includes('build') || fileName.includes('script') ||
        baseName === 'index' && (ext === '.js' || ext === '.ts')) {
        return { type: 'catapulte', name: baseName, path: filePath, role: 'Catapulte - Script/Build' };
    }
    // Cavalerie - Tests (rapides et mobiles)
    if (fileName.includes('test') || fileName.includes('spec') ||
        ext === '.test.js' || ext === '.test.ts' || ext === '.spec.js' || ext === '.spec.ts') {
        return { type: 'cavalerie', name: baseName, path: filePath, role: 'Cavalerie - Tests' };
    }
    // Infanterie - Code source principal
    if (['.ts', '.js', '.tsx', '.jsx', '.py', '.java', '.cpp', '.c', '.rs', '.go'].includes(ext)) {
        return { type: 'infanterie', name: baseName, path: filePath, role: 'Infanterie - Code source' };
    }
    // Archer - Documentation et texte
    if (['.md', '.txt', '.rst', '.adoc', 'README', 'CHANGELOG', 'LICENSE'].includes(ext) ||
        fileName.toLowerCase().includes('readme') || fileName.toLowerCase().includes('changelog')) {
        return { type: 'archer', name: baseName, path: filePath, role: 'Archer - Documentation' };
    }
    // Balliste - Assets et donnÃ©es
    if (['.json', '.yaml', '.yml', '.xml', '.csv', '.sql'].includes(ext) ||
        ext === '.png' || ext === '.jpg' || ext === '.svg' || ext === '.ico') {
        return { type: 'balliste', name: baseName, path: filePath, role: 'Balliste - Assets/DonnÃ©es' };
    }
    return null;
}
/** Analyse une structure de dossiers et crÃ©e une formation militaire */
export function analyzeFormation(repoPath, repoName) {
    const units = [];
    const scannedPaths = new Set();
    function scanDirectory(dirPath, maxDepth = 3, currentDepth = 0) {
        if (currentDepth > maxDepth || scannedPaths.has(dirPath))
            return;
        scannedPaths.add(dirPath);
        try {
            const entries = fs.readdirSync(dirPath);
            for (const entry of entries) {
                const fullPath = path.join(dirPath, entry);
                const stat = fs.statSync(fullPath);
                if (stat.isDirectory()) {
                    // Ã‰viter les dossiers systÃ¨me
                    if (!['node_modules', '.git', '.next', 'dist', 'build', '.vscode', '.idea'].includes(entry)) {
                        // Capitaine - Dossier
                        units.push({
                            type: 'capitaine',
                            name: entry,
                            path: fullPath,
                            role: 'Capitaine - Dossier'
                        });
                        // Scanner rÃ©cursivement
                        scanDirectory(fullPath, maxDepth, currentDepth + 1);
                    }
                }
                else if (stat.isFile()) {
                    const unit = classifyFile(fullPath, entry);
                    if (unit) {
                        units.push(unit);
                    }
                }
            }
        }
        catch (e) {
            // Ignore les erreurs de lecture
        }
    }
    scanDirectory(repoPath);
    // Calculer la force et le type de formation
    const catapultes = units.filter(u => u.type === 'catapulte').length;
    const infanterie = units.filter(u => u.type === 'infanterie').length;
    const capitaines = units.filter(u => u.type === 'capitaine').length;
    const cavalerie = units.filter(u => u.type === 'cavalerie').length;
    let formationType;
    let strength = units.length;
    if (strength < 10 || (catapultes <= 2 && infanterie <= 5)) {
        formationType = 'bataillon'; // Petit repo
    }
    else if (strength < 50 || capitaines <= 5) {
        formationType = 'legion'; // Moyen repo
    }
    else {
        formationType = 'armee'; // Grand repo
    }
    return {
        type: formationType,
        name: repoName,
        path: repoPath,
        units,
        strength
    };
}
/** Analyse tous les workspaces et retourne leurs formations */
export function analyzeAllFormations(root = process.cwd()) {
    const workspaces = resolveWorkspaces(root);
    const formations = {};
    // Si aucun workspace dÃ©tectÃ©, analyser le rÃ©pertoire racine
    if (Object.keys(workspaces).length === 0) {
        const rootName = path.basename(root);
        const formation = analyzeFormation(root, rootName);
        // Normaliser le chemin affichÃ©
        const relPath = path.relative(process.cwd(), formation.path);
        formation.path = relPath || ".";
        formations[rootName] = formation;
    }
    else {
        // Analyser tous les workspaces dÃ©tectÃ©s
        for (const [name, wsPath] of Object.entries(workspaces)) {
            if (!name.includes('/')) { // Uniquement les alias principaux
                const formation = analyzeFormation(wsPath, name);
                // Normaliser le chemin affichÃ© (relatif si possible)
                const relPath = path.relative(root, wsPath);
                formation.path = relPath || ".";
                formations[name] = formation;
            }
        }
    }
    return formations;
}
