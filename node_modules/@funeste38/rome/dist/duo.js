import { resolveWorkspaces, spawnLogged, exitAll, tryInstallDeps } from "./utils.js";
import { WorkspaceLogger } from "./logger.js";
/** rome duo <wsA> "<cmdA>" <wsB> "<cmdB>" */
export async function duo(wsA, cmdA, wsB, cmdB, outputOptions, detachMode) {
    const loggerA = new WorkspaceLogger("A", outputOptions || { plain: false, json: false, noEmoji: false, ci: false });
    const loggerB = new WorkspaceLogger("B", outputOptions || { plain: false, json: false, noEmoji: false, ci: false });
    const map = resolveWorkspaces();
    const a = map[wsA];
    const b = map[wsB];
    if (!a || !b) {
        const { createGlobalLogger } = await import("./logger.js");
        const globalLogger = createGlobalLogger(outputOptions || { plain: false, json: false, noEmoji: false, ci: false });
        globalLogger.error(`Rome: cible manquante. Connus: ${Object.keys(map).join(", ") || "aucun"}`);
        process.exit(1);
    }
    // Parse les commandes pour sÃ©parer cmd et args
    const [cmdA_parsed, ...argsA] = cmdA.split(/\s+/);
    const [cmdB_parsed, ...argsB] = cmdB.split(/\s+/);
    // Mode dÃ©tachÃ© : lancer en arriÃ¨re-plan et retourner immÃ©diatement
    if (detachMode) {
        const { createGlobalLogger } = await import("./logger.js");
        const globalLogger = createGlobalLogger(outputOptions || { plain: false, json: false, noEmoji: false, ci: false });
        // Fonction pour lancer un processus dÃ©tachÃ©
        const launchDetachedProcess = async (name, command, args, cwd) => {
            const { spawn } = await import("child_process");
            const path = await import("path");
            const fs = await import("fs");
            const options = {
                stdio: "pipe", // Ne pas hÃ©riter pour Ã©viter les interruptions
                detached: true,
                env: process.env,
                cwd: cwd
            };
            const child = spawn(command, args, options);
            // DÃ©tacher complÃ¨tement du processus parent
            child.unref();
            // Logs sÃ©parÃ©s pour chaque processus
            const logFile = path.join(process.cwd(), `logs`, `${name}.log`);
            if (!fs.existsSync(path.join(process.cwd(), "logs"))) {
                fs.mkdirSync(path.join(process.cwd(), "logs"));
            }
            const logStream = fs.createWriteStream(logFile, { flags: 'a' });
            child.stdout?.pipe(logStream);
            child.stderr?.pipe(logStream);
            child.on("exit", (code) => {
                const status = code === 0 ? "âœ…" : "âŒ";
                globalLogger.info(`${status} Processus ${name} terminÃ© (code: ${code})`);
            });
            return child;
        };
        // Lancer les deux processus en arriÃ¨re-plan SANS attendre
        launchDetachedProcess(`${wsA}-A`, cmdA_parsed, argsA, a);
        launchDetachedProcess(`${wsB}-B`, cmdB_parsed, argsB, b);
        globalLogger.success(`âœ… Processus dÃ©tachÃ©s lancÃ©s en arriÃ¨re-plan`);
        globalLogger.info(`ðŸ”§ Workspace A (${wsA}): ${cmdA}`);
        globalLogger.info(`ðŸŒ Workspace B (${wsB}): ${cmdB}`);
        globalLogger.info(`ðŸ“ Logs disponibles dans le dossier ./logs/`);
        return;
    }
    const ca = spawnLogged(cmdA_parsed, argsA, a, "A");
    const cb = spawnLogged(cmdB_parsed, argsB, b, "B");
    // Gestion automatique des dÃ©pendances pour les commandes npm run dev
    if (cmdA === "npm run dev") {
        ca.on("exit", async (code) => {
            if (code !== 0) {
                loggerA.info(`Ã‰chec dÃ©tectÃ©, tentative d'installation...`);
                await tryInstallDeps(a, "A");
            }
        });
    }
    if (cmdB === "npm run dev") {
        cb.on("exit", async (code) => {
            if (code !== 0) {
                loggerB.info(`Ã‰chec dÃ©tectÃ©, tentative d'installation...`);
                await tryInstallDeps(b, "B");
            }
        });
    }
    const stop = () => { exitAll([ca, cb]); process.exit(0); };
    process.on("SIGINT", stop);
    process.on("SIGTERM", stop);
    await Promise.race([new Promise(res => ca.on("exit", res)), new Promise(res => cb.on("exit", res))]);
    stop();
}
