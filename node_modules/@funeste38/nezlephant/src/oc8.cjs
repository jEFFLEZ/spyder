const { PNG } = require('pngjs');

function crc8(buf) {
  let crc = 0;
  for (let i = 0; i < buf.length; i++) {
    crc ^= buf[i];
    for (let j = 0; j < 8; j++) {
      crc = (crc & 0x80) ? ((crc << 1) ^ 0x07) & 0xff : (crc << 1) & 0xff;
    }
  }
  return crc & 0xff;
}

function encodeToOC8Png(payload, width = 0, height = 0) {
  const len = payload.length;
  if (width === 0 || height === 0) {
    const pixels = Math.ceil(len / 3);
    width = Math.ceil(Math.sqrt(pixels));
    height = Math.ceil(pixels / width);
  }
  const pixelCount = width * height;
  const pixels = Buffer.alloc(pixelCount * 4, 0);
  for (let i = 0; i < pixelCount; i++) {
    const offPayload = i * 3;
    const r = payload[offPayload] || 0;
    const g = payload[offPayload + 1] || 0;
    const b = payload[offPayload + 2] || 0;
    const c = crc8(Buffer.from([r, g, b]));
    const po = i * 4;
    pixels[po] = r;
    pixels[po + 1] = g;
    pixels[po + 2] = b;
    pixels[po + 3] = c;
  }
  const png = new PNG({ width, height });
  png.data = pixels;
  return PNG.sync.write(png);
}

function decodeFromOC8Png(pngBuf) {
  const png = PNG.sync.read(pngBuf);
  const data = png.data;
  const out = [];
  for (let i = 0; i < data.length; i += 4) {
    const r = data[i];
    const g = data[i + 1];
    const b = data[i + 2];
    const c = data[i + 3];
    if (crc8(Buffer.from([r, g, b])) !== c) break;
    out.push(r, g, b);
  }
  while (out.length && out[out.length - 1] === 0) out.pop();
  return Buffer.from(out);
}

module.exports = { crc8, encodeToOC8Png, decodeFromOC8Png };
