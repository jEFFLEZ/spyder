const crypto = require('crypto');
const { PNG } = require('pngjs');

function makePermutation(count, key) {
  const hash = crypto.createHash('sha256').update(key).digest();
  const arr = Array.from({ length: count }, (_, i) => i);
  let idx = 0;
  for (let i = count - 1; i > 0; i--) {
    const b = hash[idx++ % hash.length];
    const j = b % (i + 1);
    const tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
  }
  return arr;
}

function scramblePngBlocks(pngBuf, key, blockSize = 8) {
  const png = PNG.sync.read(pngBuf);
  const { width, height, data } = png;
  const cols = Math.ceil(width / blockSize);
  const rows = Math.ceil(height / blockSize);
  const blockCount = cols * rows;
  const perm = makePermutation(blockCount, key);

  const orig = Buffer.from(data); // read-only source
  const out = Buffer.from(data); // start with original so untouched areas remain

  for (let srcIndex = 0; srcIndex < blockCount; srcIndex++) {
    const dstIndex = perm[srcIndex];

    const srcCol = srcIndex % cols;
    const srcRow = Math.floor(srcIndex / cols);
    const dstCol = dstIndex % cols;
    const dstRow = Math.floor(dstIndex / cols);

    const srcX = srcCol * blockSize;
    const srcY = srcRow * blockSize;
    const dstX = dstCol * blockSize;
    const dstY = dstRow * blockSize;

    const blockWidth = Math.min(blockSize, width - srcX);
    const blockHeight = Math.min(blockSize, height - srcY);

    for (let by = 0; by < blockHeight; by++) {
      const srcOff = ((srcY + by) * width + srcX) * 4;
      const dstOff = ((dstY + by) * width + dstX) * 4;
      const len = blockWidth * 4;
      orig.copy(out, dstOff, srcOff, srcOff + len);
    }
  }

  const pngOut = new PNG({ width, height });
  pngOut.data = out;
  return PNG.sync.write(pngOut);
}

function unscramblePngBlocks(pngBuf, key, blockSize = 8) {
  const png = PNG.sync.read(pngBuf);
  const { width, height, data } = png;
  const cols = Math.ceil(width / blockSize);
  const rows = Math.ceil(height / blockSize);
  const blockCount = cols * rows;
  const perm = makePermutation(blockCount, key);

  const scrambled = Buffer.from(data);
  const out = Buffer.from(data);

  for (let srcIndex = 0; srcIndex < blockCount; srcIndex++) {
    const dstIndex = perm[srcIndex];

    const srcCol = srcIndex % cols;
    const srcRow = Math.floor(srcIndex / cols);
    const dstCol = dstIndex % cols;
    const dstRow = Math.floor(dstIndex / cols);

    const srcX = srcCol * blockSize;
    const srcY = srcRow * blockSize;
    const dstX = dstCol * blockSize;
    const dstY = dstRow * blockSize;

    // In scrambled image, the block originally at srcIndex is at dstIndex.
    // So copy from scrambled at dstIndex -> out at srcIndex.
    const scrX = dstX;
    const scrY = dstY;
    const outX = srcX;
    const outY = srcY;

    const blockWidth = Math.min(blockSize, width - outX);
    const blockHeight = Math.min(blockSize, height - outY);

    for (let by = 0; by < blockHeight; by++) {
      const scrOff = ((scrY + by) * width + scrX) * 4;
      const outOff = ((outY + by) * width + outX) * 4;
      const len = blockWidth * 4;
      scrambled.copy(out, outOff, scrOff, scrOff + len);
    }
  }

  const pngOut = new PNG({ width, height });
  pngOut.data = out;
  return PNG.sync.write(pngOut);
}

module.exports = { scramblePngBlocks, unscramblePngBlocks, makePermutation };
