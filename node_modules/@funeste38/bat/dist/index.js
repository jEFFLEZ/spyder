"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Instinct = exports.Sleep = exports.Immune = exports.Hormones = exports.Memory = exports.Heart = exports.Inversion = exports.Fangs = exports.Wings = exports.Ears = exports.Bat = exports.BatWings = exports.EchoRadar = void 0;
exports.wrapEcho = wrapEcho;
const batWings_1 = require("./batWings");
Object.defineProperty(exports, "BatWings", { enumerable: true, get: function () { return batWings_1.BatWings; } });
const defaultNoiseFilter = {
    ignore(result, error) {
        if (error) {
            const status = (error && (error.status || error.statusCode));
            if (status && [429, 502, 503].includes(status))
                return true;
            return false;
        }
        if (result == null)
            return true;
        if (typeof result === 'string') {
            const s = result.trim();
            if (s === '' || s === 'null' || s === 'undefined')
                return true;
            if (s.length < 5)
                return true;
        }
        if (typeof result === 'object') {
            try {
                const str = JSON.stringify(result);
                if (str === '{}' || str === '[]' || str.length < 5)
                    return true;
            }
            catch {
                return false;
            }
        }
        return false;
    }
};
function computeSignalStrength(result, error, rtt) {
    if (error)
        return 0;
    let score = 50;
    let len = 0;
    if (typeof result === 'string')
        len = result.length;
    else if (result && typeof result === 'object') {
        try {
            len = JSON.stringify(result).length;
        }
        catch {
            len = 0;
        }
    }
    else if (typeof result === 'number' || typeof result === 'boolean')
        len = 1;
    // reward longer meaningful payloads
    score += Math.min(40, Math.round((len / 1000) * 40));
    if (len < 20)
        score -= 20;
    // penalize high latency
    if (rtt > 1500)
        score -= 30;
    else if (rtt > 500)
        score -= 10;
    score = Math.max(0, Math.min(100, score));
    return score;
}
function guessOrigin(rtt, len, error) {
    if (error)
        return 'error';
    if (len < 50 && rtt < 100)
        return 'cached';
    if (rtt < 200)
        return 'local';
    if (rtt < 1000)
        return 'remote';
    return 'remote';
}
function timeoutPromise(p, ms) {
    let timer;
    return Promise.race([
        p,
        new Promise((_, rej) => {
            timer = setTimeout(() => rej(new Error('timeout')), ms);
        })
    ]).finally(() => clearTimeout(timer));
}
class EchoRadar {
    constructor(opts = {}) {
        this.inFlight = new Map();
        this.counter = 0;
        this.baselineMs = opts.baselineMs ?? 500;
        this.alpha = opts.alpha ?? 0.2;
        this.maxAttempts = opts.maxAttempts ?? 2;
        this.noiseFilter = opts.noiseFilter ?? defaultNoiseFilter;
    }
    start(key) {
        const id = `${key}:${++this.counter}`;
        this.inFlight.set(id, {
            id,
            key,
            startedAt: Date.now(),
            attempts: 1
        });
        return id;
    }
    stop(id) {
        const rec = this.inFlight.get(id);
        if (!rec)
            return null;
        const rtt = Date.now() - rec.startedAt;
        this.baselineMs =
            (1 - this.alpha) * this.baselineMs + this.alpha * rtt;
        this.inFlight.delete(id);
        return { rtt, cls: this.classify(rtt), attempts: rec.attempts };
    }
    classify(rtt) {
        if (rtt < this.baselineMs * 0.5)
            return 'short';
        if (rtt < this.baselineMs * 1.5)
            return 'normal';
        if (rtt < this.baselineMs * 3)
            return 'slow';
        return 'timeout';
    }
    getTimeoutThreshold() {
        return this.baselineMs * 3;
    }
    listInFlight() {
        return [...this.inFlight.values()];
    }
    markRetry(id) {
        const rec = this.inFlight.get(id);
        if (!rec)
            return null;
        rec.attempts += 1;
        rec.startedAt = Date.now();
        if (rec.attempts > this.maxAttempts) {
            this.inFlight.delete(id);
        }
        return rec;
    }
}
exports.EchoRadar = EchoRadar;
// Helper pour wrapper une fonction async
function wrapEcho(key, radar, fn, wings, requestType) {
    return async (...args) => {
        if (wings && requestType)
            wings.selectProfile(requestType);
        const id = radar.start(key);
        let result = null;
        let error = undefined;
        let attempts = 0;
        let dropped = false;
        while (true) {
            attempts++;
            try {
                const timeoutMs = wings ? wings.computeTimeout(radar.baselineMs) : radar.getTimeoutThreshold();
                result = await timeoutPromise(fn(...args), timeoutMs);
                const echo = radar.stop(id);
                const isNoise = radar.noiseFilter.ignore(result, undefined);
                const len = typeof result === 'string' ? result.length : (result ? JSON.stringify(result).length : 0);
                const signalStrength = computeSignalStrength(result, undefined, echo.rtt);
                const originGuess = guessOrigin(echo.rtt, len, undefined);
                if (wings) {
                    wings.applyProfile(echo.cls);
                    if (wings.shouldAbort()) {
                        wings.drop(id);
                        dropped = true;
                        return { result, ...echo, isNoise, signalStrength, originGuess, dropped };
                    }
                }
                return { result, ...echo, isNoise, signalStrength, originGuess, attempts };
            }
            catch (err) {
                error = err;
                // if wings suggest retry based on profile
                attempts = Math.max(1, attempts);
                const shouldRetry = wings ? wings.shouldRetry(attempts) : attempts < radar.maxAttempts;
                const echo = radar.stop(id) || { rtt: 0, cls: 'timeout', attempts };
                const isNoise = radar.noiseFilter.ignore(null, error);
                const signalStrength = computeSignalStrength(null, error, echo.rtt);
                const originGuess = guessOrigin(echo.rtt, 0, error);
                if (wings) {
                    wings.applyProfile(echo.cls);
                    if (wings.shouldAbort()) {
                        wings.drop(id);
                        // fire recovery asynchronously
                        // eslint-disable-next-line @typescript-eslint/no-floating-promises
                        wings.emergencyRecovery();
                        return { result: null, error, ...echo, isNoise, signalStrength, originGuess, dropped: true };
                    }
                }
                if (!shouldRetry) {
                    return { result: null, error, ...echo, isNoise, signalStrength, originGuess };
                }
                // prepare for next attempt
                if (wings)
                    wings.state.retries = attempts;
                radar.markRetry(id);
                // small backoff
                await new Promise((r) => setTimeout(r, 50 * attempts));
                continue;
            }
        }
    };
}
var bat_1 = require("./bat");
Object.defineProperty(exports, "Bat", { enumerable: true, get: function () { return bat_1.Bat; } });
var ears_1 = require("./ears");
Object.defineProperty(exports, "Ears", { enumerable: true, get: function () { return ears_1.Ears; } });
var wings_1 = require("./wings");
Object.defineProperty(exports, "Wings", { enumerable: true, get: function () { return wings_1.Wings; } });
var fangs_1 = require("./fangs");
Object.defineProperty(exports, "Fangs", { enumerable: true, get: function () { return fangs_1.Fangs; } });
var inversion_1 = require("./inversion");
Object.defineProperty(exports, "Inversion", { enumerable: true, get: function () { return inversion_1.Inversion; } });
var heart_1 = require("./heart");
Object.defineProperty(exports, "Heart", { enumerable: true, get: function () { return heart_1.Heart; } });
var memory_1 = require("./memory");
Object.defineProperty(exports, "Memory", { enumerable: true, get: function () { return memory_1.Memory; } });
var hormones_1 = require("./hormones");
Object.defineProperty(exports, "Hormones", { enumerable: true, get: function () { return hormones_1.Hormones; } });
var immune_1 = require("./immune");
Object.defineProperty(exports, "Immune", { enumerable: true, get: function () { return immune_1.Immune; } });
var sleep_1 = require("./sleep");
Object.defineProperty(exports, "Sleep", { enumerable: true, get: function () { return sleep_1.Sleep; } });
var instinct_1 = require("./instinct");
Object.defineProperty(exports, "Instinct", { enumerable: true, get: function () { return instinct_1.Instinct; } });
__exportStar(require("./types"), exports);
__exportStar(require("./profiles"), exports);
