'use strict';

var process = require('process');
var dotenv = require('dotenv');
var fs = require('fs');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var process__namespace = /*#__PURE__*/_interopNamespace(process);
var fs__default = /*#__PURE__*/_interopDefault(fs);

var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// src/Error.ts
var EnvaptErrorCodes = /* @__PURE__ */ ((EnvaptErrorCodes2) => {
  EnvaptErrorCodes2[EnvaptErrorCodes2["InvalidFallback"] = 101] = "InvalidFallback";
  EnvaptErrorCodes2[EnvaptErrorCodes2["InvalidFallbackType"] = 102] = "InvalidFallbackType";
  EnvaptErrorCodes2[EnvaptErrorCodes2["ArrayFallbackElementTypeMismatch"] = 103] = "ArrayFallbackElementTypeMismatch";
  EnvaptErrorCodes2[EnvaptErrorCodes2["FallbackConverterTypeMismatch"] = 104] = "FallbackConverterTypeMismatch";
  EnvaptErrorCodes2[EnvaptErrorCodes2["InvalidArrayConverterType"] = 201] = "InvalidArrayConverterType";
  EnvaptErrorCodes2[EnvaptErrorCodes2["InvalidBuiltInConverter"] = 202] = "InvalidBuiltInConverter";
  EnvaptErrorCodes2[EnvaptErrorCodes2["InvalidCustomConverter"] = 203] = "InvalidCustomConverter";
  EnvaptErrorCodes2[EnvaptErrorCodes2["InvalidConverterType"] = 204] = "InvalidConverterType";
  EnvaptErrorCodes2[EnvaptErrorCodes2["PrimitiveCoercionFailed"] = 205] = "PrimitiveCoercionFailed";
  EnvaptErrorCodes2[EnvaptErrorCodes2["MissingDelimiter"] = 301] = "MissingDelimiter";
  EnvaptErrorCodes2[EnvaptErrorCodes2["InvalidUserDefinedConfig"] = 302] = "InvalidUserDefinedConfig";
  EnvaptErrorCodes2[EnvaptErrorCodes2["EnvFilesNotFound"] = 303] = "EnvFilesNotFound";
  return EnvaptErrorCodes2;
})(EnvaptErrorCodes || {});
var EnvaptError = class extends Error {
  static {
    __name(this, "EnvaptError");
  }
  code;
  constructor(code, message) {
    super(message);
    this.name = `EnvaptError [${code}]`;
    this.code = code;
  }
};

// src/ListOfBuiltInConverters.ts
var ListOfBuiltInConverters = [
  "string",
  "number",
  "boolean",
  "bigint",
  "symbol",
  "integer",
  "float",
  "json",
  "array",
  "url",
  "regexp",
  "date",
  "time"
];
var BuiltInConverterTypeCheckers = {
  string: /* @__PURE__ */ __name((value) => typeof value === "string", "string"),
  number: /* @__PURE__ */ __name((value) => typeof value === "number", "number"),
  boolean: /* @__PURE__ */ __name((value) => typeof value === "boolean", "boolean"),
  bigint: /* @__PURE__ */ __name((value) => typeof value === "bigint", "bigint"),
  symbol: /* @__PURE__ */ __name((value) => typeof value === "symbol", "symbol"),
  integer: /* @__PURE__ */ __name((value) => typeof value === "number" && Number.isInteger(value), "integer"),
  float: /* @__PURE__ */ __name((value) => typeof value === "number", "float"),
  json: /* @__PURE__ */ __name((value) => {
    try {
      JSON.parse(JSON.stringify(value));
      return true;
    } catch {
      return false;
    }
  }, "json"),
  array: /* @__PURE__ */ __name((value) => Array.isArray(value), "array"),
  url: /* @__PURE__ */ __name((value) => value instanceof URL, "url"),
  regexp: /* @__PURE__ */ __name((value) => value instanceof RegExp, "regexp"),
  date: /* @__PURE__ */ __name((value) => value instanceof Date, "date"),
  time: /* @__PURE__ */ __name((value) => typeof value === "number", "time")
};

// src/Validators.ts
var Validator = class {
  static {
    __name(this, "Validator");
  }
  /**
   * Check if a value is a built-in converter type
   */
  static isBuiltInConverter(value) {
    if (typeof value === "string") return ListOfBuiltInConverters.includes(value);
    return false;
  }
  /**
   * Check if a value is an ArrayConverter configuration object
   */
  static isArrayConverter(value) {
    return typeof value === "object" && value !== null && "delimiter" in value && typeof value.delimiter === "string";
  }
  /**
   * Check if a value is a valid ArrayConverter type
   */
  static isValidArrayConverterType(value) {
    if (typeof value !== "string") return false;
    const invalidTypes = ["array", "json", "regexp"];
    if (invalidTypes.includes(value)) return false;
    const validTypes = ListOfBuiltInConverters.filter(
      (type) => !invalidTypes.includes(type)
    );
    return validTypes.includes(value);
  }
  static customConvertor(converter) {
    if (typeof converter !== "function") {
      throw new EnvaptError(
        203 /* InvalidCustomConverter */,
        `Custom converter must be a function, got ${typeof converter}.`
      );
    }
  }
  /**
   * Validate ArrayConverter configuration with runtime checks
   */
  static arrayConverter(value) {
    if (!this.isArrayConverter(value)) {
      throw new EnvaptError(301 /* MissingDelimiter */, "Must have delimiter property");
    }
    if (value.type !== void 0 && !this.isValidArrayConverterType(value.type)) {
      throw new EnvaptError(
        201 /* InvalidArrayConverterType */,
        `"${value.type}" is not a valid converter type`
      );
    }
  }
  /**
   * Validate that a string is a valid built-in converter type
   */
  static builtInConverter(value) {
    if (typeof value !== "string") {
      throw new EnvaptError(204 /* InvalidConverterType */, `Expected string, got ${typeof value}`);
    }
    if (!ListOfBuiltInConverters.includes(value)) {
      throw new EnvaptError(
        202 /* InvalidBuiltInConverter */,
        `"${value}" is not a valid converter type. Valid types are: ${ListOfBuiltInConverters.join(",")}`
      );
    }
  }
  /**
   * Validate that fallback type matches the converter's return type for built-in converters
   */
  static validateBuiltInConverterFallback(converter, fallback) {
    const typeChecker = BuiltInConverterTypeCheckers[converter];
    if (!typeChecker(fallback)) {
      throw new EnvaptError(
        104 /* FallbackConverterTypeMismatch */,
        `Fallback type does not match converter "${converter}". Expected ${converter} compatible type.`
      );
    }
  }
  /**
   * Validate that all elements in an array fallback have consistent types
   */
  static validateArrayFallbackElementTypes(fallback) {
    if (fallback.length === 0) return;
    const firstElementType = typeof fallback[0];
    const hasInconsistentTypes = fallback.some((element, index) => {
      if (index === 0) return false;
      return typeof element !== firstElementType;
    });
    if (hasInconsistentTypes) {
      throw new EnvaptError(
        103 /* ArrayFallbackElementTypeMismatch */,
        `All elements in array fallback must have the same type. Found mixed types.`
      );
    }
  }
  /**
   * Validate that array converter type matches fallback element types
   */
  static validateArrayConverterElementTypeMatch(converterType, fallback) {
    if (fallback.length === 0) return;
    const firstElement = fallback[0];
    const typeChecker = BuiltInConverterTypeCheckers[converterType];
    if (!typeChecker(firstElement)) {
      throw new EnvaptError(
        103 /* ArrayFallbackElementTypeMismatch */,
        `Array converter type "${converterType}" does not match fallback element type. Expected ${converterType} compatible elements.`
      );
    }
  }
  /**
   * Check if a value is a primitive constructor
   */
  static isPrimitiveConstructor(value) {
    return value === String || value === Number || value === Boolean || value === BigInt || value === Symbol;
  }
  /**
   * Safely coerce a fallback value using a primitive constructor
   */
  static coercePrimitiveFallback(converter, fallback) {
    if (this.isCorrectPrimitiveType(converter, fallback)) return fallback;
    return this.performPrimitiveCoercion(converter, fallback);
  }
  /**
   * Check if fallback is already the correct primitive type
   */
  static isCorrectPrimitiveType(converter, fallback) {
    if (converter === String && typeof fallback === "string") return true;
    if (converter === Number && typeof fallback === "number") return true;
    if (converter === Boolean && typeof fallback === "boolean") return true;
    if (converter === BigInt && typeof fallback === "bigint") return true;
    if (converter === Symbol && typeof fallback === "symbol") return true;
    return false;
  }
  /**
   * Perform the actual primitive coercion
   */
  static performPrimitiveCoercion(converter, fallback) {
    try {
      if (converter === String) return String(fallback);
      if (converter === Number) return Number(fallback);
      if (converter === Boolean) return Boolean(fallback);
      if (converter === BigInt) return BigInt(fallback);
      if (converter === Symbol) return Symbol.for(String(fallback));
    } catch (error) {
      throw new EnvaptError(
        205 /* PrimitiveCoercionFailed */,
        `Failed to coerce fallback value using ${converter.name}: ${error.message}`
      );
    }
    throw new EnvaptError(205 /* PrimitiveCoercionFailed */, `Unknown primitive converter: ${converter.name}`);
  }
  /**
   * Make sure the user hasn't provided prohibited options in their dotenv config
   */
  static validateDotenvConfig(config2) {
    if ("path" in config2 || "processEnv" in config2) {
      throw new EnvaptError(
        302 /* InvalidUserDefinedConfig */,
        'Custom dotenvConfig should not include "path" or "processEnv" options. Those are managed by Envapter.'
      );
    }
    const validKeys = /* @__PURE__ */ new Set(["encoding", "quiet", "debug", "override", "DOTENV_KEY"]);
    const invalidKeys = Object.keys(config2).filter((key) => !validKeys.has(key));
    if (invalidKeys.length > 0) {
      throw new EnvaptError(
        302 /* InvalidUserDefinedConfig */,
        `Invalid dotenvConfig options: ${invalidKeys.join(", ")}. Allowed options: ${Array.from(validKeys).join(", ")}`
      );
    }
    return true;
  }
  /**
   * Check if each provided path resolves to an env file by trying to access it
   */
  static validateEnvFilesExist(paths) {
    const missing = paths.filter((p) => {
      try {
        fs__default.default.accessSync(p, fs__default.default.constants.F_OK);
        return false;
      } catch {
        return true;
      }
    });
    if (missing.length > 0) {
      throw new EnvaptError(
        303 /* EnvFilesNotFound */,
        `Environment file not found at path: ${missing.join(", ")}`
      );
    }
  }
};

// src/core/EnvapterBase.ts
var EnvaptCache = /* @__PURE__ */ new Map();
var EnvapterBase = class _EnvapterBase {
  static {
    __name(this, "EnvapterBase");
  }
  static _envPaths = [".env"];
  // default path
  static _userDefinedDotenvConfig = { quiet: true };
  /**
   * Set custom .env file paths. Accepts either a single path or array of paths.
   * Setting new paths clears the cache and reloads environment variables.
   */
  static set envPaths(paths) {
    const newPaths = Array.isArray(paths) ? paths : [paths];
    Validator.validateEnvFilesExist(newPaths);
    this._envPaths = newPaths;
    this.refreshCache();
  }
  /**
   * Get currently configured .env file paths
   */
  static get envPaths() {
    return this._envPaths;
  }
  /**
   * Set custom dotenv configuration options.
   */
  static set dotenvConfig(config2) {
    Validator.validateDotenvConfig(config2);
    this._userDefinedDotenvConfig = config2;
    this.refreshCache();
  }
  /**
   * Get current dotenv configuration options
   */
  static get dotenvConfig() {
    return this._userDefinedDotenvConfig;
  }
  static refreshCache() {
    EnvaptCache.clear();
    void this.config;
  }
  static get config() {
    if (EnvaptCache.size === 0) {
      const isolatedEnv = { ...process__namespace.env };
      try {
        const effectiveConfig = { path: this._envPaths, processEnv: isolatedEnv, ...this._userDefinedDotenvConfig };
        if (!("override" in effectiveConfig)) effectiveConfig.override = true;
        dotenv.config(effectiveConfig);
      } catch {
      }
      for (const [key, value] of Object.entries(isolatedEnv)) EnvaptCache.set(key, value);
    }
    return EnvaptCache;
  }
  /**
   * Get raw environment variable value without parsing or conversion.
   */
  getRaw(key) {
    return _EnvapterBase.config.get(key);
  }
  /**
   * Get the first non-empty environment variable among a list of keys.
   * This is the core helper used for `keys: []` support at higher levels.
   */
  getRawFrom(keys) {
    for (const key of keys) {
      const value = _EnvapterBase.config.get(key);
      if (value !== void 0 && value !== null && value !== "") {
        return value;
      }
    }
    return void 0;
  }
};

// src/BuiltInConverters.ts
var BuiltInConverters = class _BuiltInConverters {
  static {
    __name(this, "BuiltInConverters");
  }
  static string(raw, fallback) {
    return String(raw) || fallback;
  }
  static number(raw, fallback) {
    const parsed = Number(raw);
    return Number.isNaN(parsed) ? fallback : parsed;
  }
  static boolean(raw, fallback) {
    const lower = raw.toLowerCase().trim();
    const truthyValues = ["1", "yes", "true", "on"];
    const falsyValues = ["0", "no", "false", "off"];
    if (truthyValues.includes(lower)) return true;
    if (falsyValues.includes(lower)) return false;
    return fallback;
  }
  static bigint(raw, fallback) {
    try {
      return BigInt(raw);
    } catch {
      return fallback;
    }
  }
  static symbol(raw, fallback) {
    try {
      return raw ? Symbol.for(raw) : fallback;
    } catch {
      return fallback;
    }
  }
  static integer(raw, fallback) {
    const parsed = Number.parseInt(raw, 10);
    return Number.isNaN(parsed) ? fallback : parsed;
  }
  static float(raw, fallback) {
    const parsed = Number.parseFloat(raw);
    return Number.isNaN(parsed) ? fallback : parsed;
  }
  static json(raw, fallback) {
    try {
      return JSON.parse(raw);
    } catch {
      return fallback;
    }
  }
  static array(raw, fallback, delimiter = ",") {
    if (raw.trim() === "") return [];
    const arr = raw.split(delimiter).map((item) => item.trim()).filter(Boolean);
    return arr.length ? arr : fallback;
  }
  static url(raw, fallback) {
    try {
      return new URL(raw);
    } catch {
      return fallback;
    }
  }
  static regexp(raw, fallback) {
    try {
      const match = raw.match(new RegExp(String.raw`^\/(.+)\/([gimsuvy]*)$`));
      if (match) return new RegExp(match[1], match[2]);
      return new RegExp(raw);
    } catch {
      return fallback;
    }
  }
  static date(raw, fallback) {
    if (new RegExp(String.raw`^\d+$`).test(raw)) {
      const timestamp = parseInt(raw, 10);
      const parsed2 = new Date(timestamp);
      return Number.isNaN(parsed2.getTime()) ? fallback : parsed2;
    }
    const isoRegex = new RegExp(String.raw`^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d{3})?Z$`, "u");
    if (!isoRegex.test(raw)) return fallback;
    const parsed = new Date(raw);
    return Number.isNaN(parsed.getTime()) ? fallback : parsed;
  }
  static time(raw, fallback) {
    const match = raw.match(new RegExp(String.raw`^(\d+(?:\.\d+)?)(ms|s|m|h)?$`, "u"));
    if (!match) return fallback;
    const [, numStr, capturedUnit] = match;
    if (!numStr) return fallback;
    const value = Number.parseFloat(numStr);
    if (Number.isNaN(value)) return fallback;
    const unit = capturedUnit ?? "ms";
    const SECONDS_TO_MS = 1e3;
    const SECONDS_PER_MINUTE = 60;
    const MINUTES_PER_HOUR = 60;
    const MINUTES_TO_MS = SECONDS_PER_MINUTE * SECONDS_TO_MS;
    const HOURS_TO_MS = MINUTES_PER_HOUR * MINUTES_TO_MS;
    if (unit === "ms") return value;
    if (unit === "s") return value * SECONDS_TO_MS;
    if (unit === "m") return value * MINUTES_TO_MS;
    return value * HOURS_TO_MS;
  }
  /**
   * Process array with custom converter config
   */
  static processArrayConverter(raw, fallback, config2) {
    if (raw.trim() === "") return [];
    const items = raw.split(config2.delimiter).map((item) => String(item).trim()).filter(Boolean);
    if (!items.length) return fallback ? fallback : void 0;
    const type = config2.type;
    if (!type) return items;
    const converter = _BuiltInConverters.getConverter(type);
    return items.map((item) => {
      const converted = converter(item, void 0);
      return converted ?? item;
    });
  }
  /**
   * Get the converter function for a built-in converter type
   */
  static getConverter(type) {
    const converters = {
      string: _BuiltInConverters.string,
      number: _BuiltInConverters.number,
      boolean: _BuiltInConverters.boolean,
      integer: _BuiltInConverters.integer,
      bigint: _BuiltInConverters.bigint,
      symbol: _BuiltInConverters.symbol,
      float: _BuiltInConverters.float,
      json: _BuiltInConverters.json,
      array: _BuiltInConverters.array,
      url: _BuiltInConverters.url,
      regexp: _BuiltInConverters.regexp,
      date: _BuiltInConverters.date,
      time: _BuiltInConverters.time
    };
    return converters[type];
  }
};

// src/Parser.ts
var Parser = class {
  constructor(envService) {
    this.envService = envService;
  }
  static {
    __name(this, "Parser");
  }
  TEMPLATE_REGEX = /\${\w*}/g;
  /**
   * Resolve template variables in a string while handling circular references and missing variables
   * @internal
   */
  resolveTemplate(key, value, stack = /* @__PURE__ */ new Set()) {
    stack.add(key);
    const out = value.replace(this.TEMPLATE_REGEX, (template) => {
      const variable = template.slice(2, -1);
      if (stack.has(variable)) return template;
      const raw = this.envService.getRaw(variable);
      if (!raw || raw === "") return template;
      const resolved = this.resolveTemplate(variable, raw, new Set(stack));
      if (resolved.includes(`\${${key}}`)) return template;
      if (resolved === raw && /\$\{[^}]*\}/.test(resolved)) return template;
      return resolved;
    });
    stack.delete(key);
    return out;
  }
  convertValue(key, fallback, converter, hasFallback) {
    const resolvedConverter = this.resolveConverter(converter, fallback);
    const processedFallback = this.processFallbackForConverter(resolvedConverter, fallback);
    if (Validator.isArrayConverter(resolvedConverter)) {
      return this.processArrayConverter(key, processedFallback, resolvedConverter, hasFallback);
    }
    if (Validator.isPrimitiveConstructor(resolvedConverter)) {
      const stringConverter = this.convertPrimitiveToString(resolvedConverter);
      return this.processBuiltInConverter(key, processedFallback, stringConverter, hasFallback, true);
    }
    if (Validator.isBuiltInConverter(resolvedConverter)) {
      return this.processBuiltInConverter(key, processedFallback, resolvedConverter, hasFallback, false);
    }
    return this.processCustomConverter(key, processedFallback, resolvedConverter, hasFallback);
  }
  processFallbackForConverter(converter, fallback) {
    if (Validator.isPrimitiveConstructor(converter) && fallback !== void 0) {
      return Validator.coercePrimitiveFallback(converter, fallback);
    }
    return fallback;
  }
  convertPrimitiveToString(primitiveConstructor) {
    if (primitiveConstructor === String) return "string";
    if (primitiveConstructor === Number) return "number";
    if (primitiveConstructor === Boolean) return "boolean";
    if (primitiveConstructor === BigInt) return "bigint";
    if (primitiveConstructor === Symbol) return "symbol";
    throw new EnvaptError(204 /* InvalidConverterType */, `Unknown primitive constructor`);
  }
  processBuiltInConverter(key, fallback, resolvedConverter, hasFallback, wasOriginallyConstructor) {
    Validator.builtInConverter(resolvedConverter);
    if (hasFallback && fallback !== void 0 && !wasOriginallyConstructor) {
      Validator.validateBuiltInConverterFallback(resolvedConverter, fallback);
      if (resolvedConverter === "array" && Array.isArray(fallback)) {
        Validator.validateArrayFallbackElementTypes(fallback);
      }
    }
    const parsed = this.envService.get(key, void 0);
    if (parsed === void 0) return hasFallback ? fallback : null;
    const converterFn = BuiltInConverters.getConverter(resolvedConverter);
    const result = converterFn(parsed, fallback);
    if (result === void 0 && !hasFallback) return null;
    return result;
  }
  processArrayConverter(key, fallback, resolvedConverter, hasFallback) {
    Validator.arrayConverter(resolvedConverter);
    if (hasFallback && fallback !== void 0 && !Array.isArray(fallback)) {
      throw new EnvaptError(
        101 /* InvalidFallback */,
        `ArrayConverter requires that the fallback be an array, got ${typeof fallback}`
      );
    }
    if (hasFallback && Array.isArray(fallback)) {
      Validator.validateArrayFallbackElementTypes(fallback);
      if (resolvedConverter.type) {
        Validator.validateArrayConverterElementTypeMatch(resolvedConverter.type, fallback);
      }
    }
    const parsed = this.envService.get(key, void 0);
    if (parsed === void 0) return hasFallback ? fallback : null;
    const result = BuiltInConverters.processArrayConverter(parsed, fallback, resolvedConverter);
    if (result === void 0 && !hasFallback) return null;
    return result;
  }
  processCustomConverter(key, fallback, resolvedConverter, _hasFallback) {
    Validator.customConvertor(resolvedConverter);
    const raw = this.envService.get(key, void 0);
    const fn = resolvedConverter;
    return fn(raw, fallback);
  }
  resolveConverter(converter, fallback) {
    if (converter) return converter;
    const fallbackType = typeof fallback;
    if (fallbackType === "number") return "number";
    if (fallbackType === "boolean") return "boolean";
    if (fallbackType === "bigint") return "bigint";
    if (fallbackType === "symbol") return "symbol";
    return "string";
  }
};

// src/core/EnvironmentMethods.ts
var Environment = /* @__PURE__ */ ((Environment2) => {
  Environment2[Environment2["Development"] = 0] = "Development";
  Environment2[Environment2["Staging"] = 1] = "Staging";
  Environment2[Environment2["Production"] = 2] = "Production";
  return Environment2;
})(Environment || {});
var EnvironmentMethods = class _EnvironmentMethods extends EnvapterBase {
  static {
    __name(this, "EnvironmentMethods");
  }
  static _environment;
  static determineEnvironment(env2) {
    const environment = env2 ?? this.getRawValue("ENVIRONMENT", this.getRawValue("ENV", this.getRawValue("NODE_ENV", "development")));
    if (typeof environment === "string") {
      this._environment = environment.toLowerCase() === "production" ? 2 /* Production */ : environment === "staging" ? 1 /* Staging */ : 0 /* Development */;
    } else {
      this._environment = environment;
    }
  }
  static getRawValue(key, fallback) {
    return this.config.get(key) || fallback;
  }
  /**
   * Get the current application environment
   */
  static get environment() {
    if (this._environment === void 0) {
      this.determineEnvironment();
    }
    return this._environment;
  }
  /**
   * Set the application environment. Accepts either Environment enum or string value.
   */
  static set environment(env2) {
    this.determineEnvironment(env2);
  }
  /**
   * @see {@link EnvironmentMethods.environment}
   */
  get environment() {
    return _EnvironmentMethods.environment;
  }
  /**
   * @see {@link EnvironmentMethods.environment}
   */
  set environment(env2) {
    _EnvironmentMethods.determineEnvironment(env2);
  }
  /**
   * Check if the current environment is production
   */
  static get isProduction() {
    return this.environment === 2 /* Production */;
  }
  /**
   * @see {@link EnvironmentMethods.isProduction}
   */
  get isProduction() {
    return _EnvironmentMethods.environment === 2 /* Production */;
  }
  /**
   * Check if the current environment is staging
   */
  static get isStaging() {
    return this.environment === 1 /* Staging */;
  }
  /**
   * @see {@link EnvironmentMethods.isStaging}
   */
  get isStaging() {
    return _EnvironmentMethods.environment === 1 /* Staging */;
  }
  /**
   * Check if the current environment is development
   */
  static get isDevelopment() {
    return this.environment === 0 /* Development */;
  }
  /**
   * @see {@link EnvironmentMethods.isDevelopment}
   */
  get isDevelopment() {
    return _EnvironmentMethods.environment === 0 /* Development */;
  }
  static refreshCache() {
    super.refreshCache();
    this._environment = void 0;
  }
};

// src/core/PrimitiveMethods.ts
var PrimitiveMethods = class _PrimitiveMethods extends EnvironmentMethods {
  static {
    __name(this, "PrimitiveMethods");
  }
  static parser = new Parser(new _PrimitiveMethods());
  static _get(key, type, def) {
    const rawVal = this.config.get(key);
    if (!rawVal) return def;
    const parsed = this.parser.resolveTemplate(key, String(rawVal));
    let result;
    if (type === 1 /* Number */) result = BuiltInConverters.number(parsed, def);
    else if (type === 2 /* Boolean */) result = BuiltInConverters.boolean(parsed, def);
    else if (type === 3 /* BigInt */) result = BuiltInConverters.bigint(parsed, def);
    else if (type === 4 /* Symbol */) result = BuiltInConverters.symbol(parsed, def);
    else result = BuiltInConverters.string(parsed, def);
    return result;
  }
  /**
   * Get a string environment variable with optional fallback.
   * Supports template variable resolution using $\{VAR\} syntax.
   */
  static get(key, def) {
    return this._get(key, 0 /* String */, def);
  }
  /**
   * @see {@link PrimitiveMethods.get}
   */
  get(key, def) {
    return _PrimitiveMethods._get(key, 0 /* String */, def);
  }
  /**
   * Get a number environment variable with optional fallback.
   * Automatically converts string values to numbers.
   */
  static getNumber(key, def) {
    return this._get(key, 1 /* Number */, def);
  }
  /**
   * @see {@link PrimitiveMethods.getNumber}
   */
  getNumber(key, def) {
    return _PrimitiveMethods._get(key, 1 /* Number */, def);
  }
  /**
   * Get a boolean environment variable with optional fallback.
   * Recognizes: `1`, `yes`, `true`, 'on' as **true**; `0`, `no`, `false`, 'off' as **false** (case-insensitive).
   */
  static getBoolean(key, def) {
    return this._get(key, 2 /* Boolean */, def);
  }
  /**
   * @see {@link PrimitiveMethods.getBoolean}
   */
  getBoolean(key, def) {
    return _PrimitiveMethods._get(key, 2 /* Boolean */, def);
  }
  /**
   * Get a bigint environment variable with optional fallback.
   * Automatically converts string values to bigint.
   */
  static getBigInt(key, def) {
    return this._get(key, 3 /* BigInt */, def);
  }
  /**
   * @see {@link PrimitiveMethods.getBigInt}
   */
  getBigInt(key, def) {
    return _PrimitiveMethods._get(key, 3 /* BigInt */, def);
  }
  /**
   * Get a symbol environment variable with optional fallback.
   * Creates a symbol from the string value.
   */
  static getSymbol(key, def) {
    return this._get(key, 4 /* Symbol */, def);
  }
  /**
   * @see {@link PrimitiveMethods.getSymbol}
   */
  getSymbol(key, def) {
    return _PrimitiveMethods._get(key, 4 /* Symbol */, def);
  }
};

// src/core/AdvancedMethods.ts
var AdvancedMethods = class _AdvancedMethods extends PrimitiveMethods {
  static {
    __name(this, "AdvancedMethods");
  }
  static getUsing(key, converter, fallback) {
    const rawVal = this.config.get(key);
    if (!rawVal) return fallback;
    const hasFallback = fallback !== void 0;
    const result = this.parser.convertValue(key, fallback, converter, hasFallback);
    return result;
  }
  getUsing(key, converter, fallback) {
    return _AdvancedMethods.getUsing(key, converter, fallback);
  }
  /**
   * Get an environment variable using a custom converter function.
   */
  static getWith(key, converter, fallback) {
    const rawVal = this.config.get(key);
    if (!rawVal) return fallback;
    const hasFallback = fallback !== void 0;
    const result = this.parser.convertValue(
      key,
      fallback,
      converter,
      hasFallback
    );
    return result;
  }
  /**
   * @see {@link AdvancedMethods.getWith}
   */
  getWith(key, converter, fallback) {
    return _AdvancedMethods.getWith(key, converter, fallback);
  }
};

// src/Envapter.ts
var Envapter = class _Envapter extends AdvancedMethods {
  static {
    __name(this, "Envapter");
  }
  /**
   * Tagged template literal for resolving environment variables in template strings.
   *
   * @example
   * ```ts
   * // Given API_HOST=api.example.com and API_PORT=8080 in environment
   * const endpoint = Envapter.resolve`Connecting to ${'API_HOST'}:${'API_PORT'}`;
   * // Returns: "Connecting to api.example.com:8080"
   *
   * // Works with template variables in .env too:
   * // API_URL=https://${API_HOST}:${API_PORT}
   * const message = Envapter.resolve`Service endpoint: ${'API_URL'}`;
   * // Returns: "Service endpoint: https://api.example.com:8080"
   * ```
   */
  static resolve(strings, ...keys) {
    return strings.reduce((result, string, i) => {
      const envKey = keys[i];
      const envValue = envKey ? super.get(envKey, "") : "";
      return result + string + envValue;
    }, "");
  }
  /**
   * @see {@link Envapter.resolve}
   */
  resolve(strings, ...keys) {
    return _Envapter.resolve(strings, ...keys);
  }
};

// src/Envapt.ts
function createPropertyDecorator(key, fallback, converter, hasFallback) {
  return function(target, prop) {
    const propKey = String(prop);
    const className = typeof target === "function" ? target.name : target.constructor.name;
    const cacheKey = `${className}.${propKey}`;
    Object.defineProperty(target, propKey, {
      get: /* @__PURE__ */ __name(function() {
        let value = EnvaptCache.get(cacheKey);
        if (value === void 0) {
          const parser = new Parser(new Envapter());
          value = parser.convertValue(key, fallback, converter, hasFallback);
          EnvaptCache.set(cacheKey, value);
        }
        return value;
      }, "get"),
      configurable: false,
      enumerable: true
    });
  };
}
__name(createPropertyDecorator, "createPropertyDecorator");
function Envapt(key, fallbackOrOptions, converter) {
  let fallback;
  let actualConverter;
  let hasFallback = true;
  if (fallbackOrOptions && typeof fallbackOrOptions === "object" && ("fallback" in fallbackOrOptions || "converter" in fallbackOrOptions)) {
    const options = fallbackOrOptions;
    fallback = options.fallback;
    actualConverter = options.converter;
    hasFallback = "fallback" in options;
  } else {
    fallback = fallbackOrOptions;
    actualConverter = converter;
    hasFallback = arguments.length > 1;
  }
  return createPropertyDecorator(key, fallback, actualConverter, hasFallback);
}
__name(Envapt, "Envapt");

// src/Converters.ts
var Converters = /* @__PURE__ */ ((Converters2) => {
  Converters2["String"] = "string";
  Converters2["Number"] = "number";
  Converters2["Boolean"] = "boolean";
  Converters2["Bigint"] = "bigint";
  Converters2["Symbol"] = "symbol";
  Converters2["Integer"] = "integer";
  Converters2["Float"] = "float";
  Converters2["Json"] = "json";
  Converters2["Array"] = "array";
  Converters2["Url"] = "url";
  Converters2["Regexp"] = "regexp";
  Converters2["Date"] = "date";
  Converters2["Time"] = "time";
  return Converters2;
})(Converters || {});

exports.Converters = Converters;
exports.Envapt = Envapt;
exports.EnvaptError = EnvaptError;
exports.EnvaptErrorCodes = EnvaptErrorCodes;
exports.Envapter = Envapter;
exports.Environment = Environment;
//# sourceMappingURL=index.cjs.map
//# sourceMappingURL=index.cjs.map