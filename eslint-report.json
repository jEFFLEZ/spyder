[{"filePath":"D:\\qflush\\src\\chain\\smartChain.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\qflush\\src\\cli\\help.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\qflush\\src\\commands\\checksum.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\qflush\\src\\commands\\compose.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\qflush\\src\\commands\\config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\qflush\\src\\commands\\detect.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\qflush\\src\\commands\\doctor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\qflush\\src\\commands\\exodia.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\qflush\\src\\commands\\inspect.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\qflush\\src\\commands\\kill.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\qflush\\src\\commands\\license-activate.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\qflush\\src\\commands\\license-status.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\qflush\\src\\commands\\license.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\qflush\\src\\commands\\npz-inspect.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\qflush\\src\\commands\\npz-scores.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\qflush\\src\\commands\\purge.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\qflush\\src\\commands\\start.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'spawnSafe' is defined but never used.","line":3,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'doRestart' is assigned a value but never used.","line":21,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":21,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'maxRestarts' is assigned a value but never used.","line":22,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":22,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'restarts' is assigned a value but never used.","line":138,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":138,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'child' is assigned a value but never used.","line":145,"column":17,"nodeType":"Identifier","messageId":"unusedVar","endLine":145,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { detectModules } from \"../utils/detect\";\r\nimport logger from \"../utils/logger\";\r\nimport { spawnSafe, ensurePackageInstalled, pathExists, rebuildInstructionsFor } from \"../utils/exec\";\r\nimport { resolvePaths, SERVICE_MAP } from \"../utils/paths\";\r\nimport { qflushOptions } from \"../chain/smartChain\";\r\nimport { resolvePackagePath, readPackageJson } from \"../utils/package\";\r\nimport { startProcess } from \"../supervisor\";\r\nimport { waitForService } from \"../utils/health\";\r\nimport { runCustomsCheck, hasBlockingIssues, ModuleDescriptor } from \"../utils/npz-customs\";\r\nimport npz from \"../utils/npz\";\r\n\r\nexport async function runStart(opts?: qflushOptions) {\r\n  logger.info(\"qflush: starting modules...\");\r\n  const detected = opts?.detected || (await detectModules());\r\n  const paths = resolvePaths(detected);\r\n\r\n  const services = opts?.services && opts.services.length ? opts.services : Object.keys(SERVICE_MAP);\r\n  const flags = opts?.flags || {};\r\n\r\n  const waitForStart = Boolean(flags[\"wait\"] || flags[\"--wait\"] || false);\r\n  const doRestart = Boolean(flags[\"restart\"] || flags[\"--restart\"] || flags[\"force\"] || false);\r\n  const maxRestarts = typeof flags[\"restartCount\"] === \"number\" ? (flags[\"restartCount\"] as number) : 3;\r\n\r\n  const procs: Promise<void>[] = [];\r\n\r\n  async function startWithCustoms(modName: string) {\r\n    const p = (opts?.modulePaths && opts.modulePaths[modName]) || paths[modName];\r\n    const pkg = SERVICE_MAP[modName] && SERVICE_MAP[modName].pkg;\r\n\r\n    const modDesc: ModuleDescriptor = { name: modName, pkg, cwd: p || process.cwd() };\r\n\r\n    // run customs\r\n    const report = await runCustomsCheck(modDesc);\r\n    if (hasBlockingIssues(report)) {\r\n      logger.warn(`supervisor: ${modName} blocked at customs, not starting.`);\r\n      return;\r\n    }\r\n\r\n    // if an explicit path is provided, prefer to run it directly\r\n    if (p) {\r\n      try {\r\n        const pkgJson = readPackageJson(p);\r\n        if (pkgJson && pkgJson.bin) {\r\n          const binEntry = typeof pkgJson.bin === \"string\" ? pkgJson.bin : Object.values(pkgJson.bin)[0];\r\n          const binPath = require(\"path\").join(p, binEntry);\r\n          const runCmd = pathExists(binPath) && binPath.endsWith('.js') ? { cmd: process.execPath, args: [binPath], cwd: p } : { cmd: binPath, args: [], cwd: p };\r\n          logger.info(`Launching ${modName} -> ${runCmd.cmd} ${runCmd.args.join(\" \")}`);\r\n          startProcess(modName, runCmd.cmd, runCmd.args, { cwd: runCmd.cwd });\r\n          return;\r\n        }\r\n      } catch (e) {\r\n        logger.warn(`Failed to run local path for ${modName}: ${e}`);\r\n      }\r\n    }\r\n\r\n    // otherwise, use NPZ resolver as primary\r\n    if (pkg) {\r\n      const resolved = npz.npzResolve(pkg, { cwd: p || process.cwd() });\r\n      if (!resolved || resolved.gate === 'fail') {\r\n        logger.warn(`${modName} path and package not found or NPZ failed to resolve, skipping`);\r\n        return;\r\n      }\r\n\r\n      if (resolved.gate === 'dlx') {\r\n        const ok = ensurePackageInstalled(pkg);\r\n        if (!ok) {\r\n          logger.warn(`${modName} not found and failed to install ${pkg}, skipping`);\r\n          return;\r\n        }\r\n      }\r\n\r\n      const runCmd = { cmd: resolved.cmd as string, args: resolved.args || [], cwd: resolved.cwd };\r\n      logger.info(`Launching ${modName} -> ${runCmd.cmd} ${runCmd.args.join(\" \")}`);\r\n      startProcess(modName, runCmd.cmd, runCmd.args, { cwd: runCmd.cwd });\r\n      return;\r\n    }\r\n\r\n    logger.warn(`${modName} has no runnable entry, skipping`);\r\n  }\r\n\r\n  for (const mod of services) {\r\n    const promise = (async () => {\r\n      // Use enhanced master flow which handles missing local bins and robust spawn\r\n      const p = (opts?.modulePaths && opts.modulePaths[mod]) || paths[mod];\r\n      const pkg = SERVICE_MAP[mod] && SERVICE_MAP[mod].pkg;\r\n\r\n      // resolve package path (local node_modules or provided path)\r\n      let pkgPath = p;\r\n      if (!pkgPath && pkg) pkgPath = resolvePackagePath(pkg);\r\n\r\n      if (!pkgPath && pkg) {\r\n        const ok = ensurePackageInstalled(pkg);\r\n        if (!ok) {\r\n          logger.warn(`${mod} not found and failed to install ${pkg}, skipping`);\r\n          return;\r\n        }\r\n        pkgPath = resolvePackagePath(pkg);\r\n      }\r\n\r\n      if (!pkgPath) {\r\n        // fallback to customs+npz flow\r\n        await startWithCustoms(mod);\r\n        return;\r\n      }\r\n\r\n      const pkgJson = readPackageJson(pkgPath);\r\n\r\n      // choose how to run: package bin if present, else npz resolver\r\n      let runCmd: { cmd: string; args: string[]; cwd?: string } | null = null;\r\n      if (pkgJson && pkgJson.bin) {\r\n        const binEntry = typeof pkgJson.bin === \"string\" ? pkgJson.bin : Object.values(pkgJson.bin)[0];\r\n        const binPath = require(\"path\").join(pkgPath, binEntry);\r\n\r\n        // prefer running via node when bin is a JS file inside package\r\n        if (binPath.endsWith(\".js\") && pathExists(binPath)) {\r\n          runCmd = { cmd: process.execPath, args: [binPath], cwd: pkgPath };\r\n        } else if (pathExists(binPath)) {\r\n          runCmd = { cmd: binPath, args: [], cwd: pkgPath };\r\n        } else {\r\n          logger.warn(`${mod} bin entry not found at ${binPath}. ${rebuildInstructionsFor(pkgPath)}`);\r\n          return;\r\n        }\r\n      } else if (pkg) {\r\n        // fallback to npz resolver\r\n        const resolved = npz.npzResolve(pkg, { cwd: pkgPath });\r\n        if (!resolved || resolved.gate === 'fail') {\r\n          logger.warn(`${mod} has no runnable entry, skipping`);\r\n          return;\r\n        }\r\n        runCmd = { cmd: resolved.cmd as string, args: resolved.args || [], cwd: resolved.cwd };\r\n      }\r\n\r\n      if (!runCmd) {\r\n        logger.warn(`${mod} has no runnable entry, skipping`);\r\n        return;\r\n      }\r\n\r\n      const restarts = 0;\r\n\r\n      const spawnOnce = (): Promise<void> => {\r\n        return new Promise((resolve) => {\r\n          logger.info(`Launching ${mod} -> ${runCmd!.cmd} ${runCmd!.args.join(\" \")}`);\r\n\r\n          // use supervisor to manage and persist process\r\n          const child = startProcess(mod, runCmd!.cmd, runCmd!.args, { cwd: runCmd!.cwd });\r\n\r\n          if (waitForStart) {\r\n            // try to wait for a health endpoint if provided in flags\r\n            const svcUrl = flags[\"health-url\"] || flags[\"health\"];\r\n            const svcPort = flags[\"health-port\"] || undefined;\r\n            if (svcUrl) {\r\n              waitForService(svcUrl as string, svcPort as any).then((ok) => {\r\n                if (ok) logger.success(`${mod} passed health check`);\r\n                else logger.warn(`${mod} failed health check`);\r\n                resolve();\r\n              });\r\n            } else {\r\n              // wait for spawn via PID persistence\r\n              setTimeout(() => {\r\n                logger.info(`${mod} started (delayed wait).`);\r\n                resolve();\r\n              }, 2000);\r\n            }\r\n          } else {\r\n            resolve();\r\n          }\r\n\r\n          // child exit handled by supervisor\r\n        });\r\n      };\r\n\r\n      // start the first time and optionally wait\r\n      await spawnOnce();\r\n\r\n      // restart logic handled by supervisor-level events, keep simple here\r\n    })();\r\n    procs.push(promise);\r\n  }\r\n\r\n  await Promise.all(procs);\r\n\r\n  logger.success(\"qflush: start sequence initiated for selected modules\");\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\qflush\\src\\compose\\fclParser.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\qflush\\src\\compose\\parser.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\qflush\\src\\daemon\\qflushd.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'removed' is assigned a value but never used.","line":124,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":124,"endColumn":16}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import 'dotenv/config';\r\nconst express = require('express');\r\nconst fs = require('fs');\r\nconst path = require('path');\r\n\r\n// optional Redis support\r\nlet Redis: any = null;\r\nlet redisClient: any = null;\r\nconst REDIS_URL = process.env.REDIS_URL || process.env.QFLUSH_REDIS_URL || '';\r\nif (REDIS_URL) {\r\n  try {\r\n    // require lazily so repo doesn't force dependency\r\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\r\n    Redis = require('ioredis');\r\n    redisClient = new Redis(REDIS_URL);\r\n    // best-effort connect\r\n    redisClient.on('error', (err: any) => {\r\n      console.warn('qflush: redis error', String(err));\r\n      redisClient = null;\r\n    });\r\n  } catch (e) {\r\n    // ignore if ioredis not installed\r\n    redisClient = null;\r\n  }\r\n}\r\n\r\n// try to import gumroad helper if present\r\nlet gumroad: any = null;\r\ntry {\r\n  // eslint-disable-next-line @typescript-eslint/no-var-requires\r\n  gumroad = require('../utils/gumroad-license');\r\n} catch (e) {\r\n  // ignore if not available\r\n}\r\n\r\nconst PORT = process.env.QFLUSHD_PORT ? Number(process.env.QFLUSHD_PORT) : 4500;\r\nconst AUDIT_DIR = path.join(process.cwd(), '.qflush');\r\nconst AUDIT_LOG = path.join(AUDIT_DIR, 'license-activations.log');\r\n\r\nfunction ensureAuditDir() {\r\n  try {\r\n    if (!fs.existsSync(AUDIT_DIR)) fs.mkdirSync(AUDIT_DIR, { recursive: true });\r\n  } catch (e) {\r\n    // ignore\r\n  }\r\n}\r\n\r\nfunction audit(line: any) {\r\n  try {\r\n    ensureAuditDir();\r\n    fs.appendFileSync(AUDIT_LOG, (typeof line === 'string' ? line : JSON.stringify(line)) + '\\n', 'utf8');\r\n  } catch (e) {\r\n    // ignore\r\n  }\r\n}\r\n\r\nconst app = express();\r\napp.use(express.json());\r\n\r\n// --- One-time checksum cache ---\r\n// If Redis is configured, use Redis keys with TTL and a sorted set index for listing. Otherwise fallback to in-memory Map.\r\nconst CHECKSUM_DEFAULT_TTL_MS = Number(process.env.QFLUSH_CHECKSUM_TTL_MS) || 60 * 1000; // 60 seconds default\r\n\r\n// in-memory fallback store\r\ntype ChecksumEntry = { checksum: string; expiresAt: number };\r\nconst checksumCache = new Map<string, ChecksumEntry>();\r\n\r\n// Redis key helpers\r\nconst REDIS_KEY_PREFIX = 'qflush:npz:checksum:';\r\nconst REDIS_INDEX_KEY = 'qflush:npz:checksum:ids';\r\n\r\nasync function redisStore(id: string, checksum: string, ttlMs: number) {\r\n  if (!redisClient) return false;\r\n  const key = REDIS_KEY_PREFIX + id;\r\n  const expiresAt = Date.now() + ttlMs;\r\n  // set key with PX TTL\r\n  await redisClient.set(key, checksum, 'PX', ttlMs);\r\n  // add to sorted set with score = expiresAt\r\n  await redisClient.zadd(REDIS_INDEX_KEY, expiresAt, id);\r\n  return true;\r\n}\r\n\r\nasync function redisGet(id: string) {\r\n  if (!redisClient) return null;\r\n  const key = REDIS_KEY_PREFIX + id;\r\n  const val = await redisClient.get(key);\r\n  if (!val) return null;\r\n  // obtain TTL to compute expiresAt\r\n  const ttlMs = await redisClient.pttl(key);\r\n  const expiresAt = Date.now() + (ttlMs > 0 ? ttlMs : 0);\r\n  return { checksum: val, expiresAt };\r\n}\r\n\r\nasync function redisDelete(id: string) {\r\n  if (!redisClient) return false;\r\n  const key = REDIS_KEY_PREFIX + id;\r\n  await redisClient.del(key);\r\n  await redisClient.zrem(REDIS_INDEX_KEY, id);\r\n  return true;\r\n}\r\n\r\nasync function redisList() {\r\n  if (!redisClient) return [] as { id: string; expiresAt: number }[];\r\n  // remove expired ids from index\r\n  const now = Date.now();\r\n  await redisClient.zremrangebyscore(REDIS_INDEX_KEY, 0, now - 1);\r\n  const items = await redisClient.zrangebyscore(REDIS_INDEX_KEY, now, '+inf', 'WITHSCORES');\r\n  // zrangebyscore with WITHSCORES returns [id, score, id, score, ...]\r\n  const results: { id: string; expiresAt: number }[] = [];\r\n  for (let i = 0; i < items.length; i += 2) {\r\n    const id = items[i];\r\n    const score = Number(items[i + 1]);\r\n    results.push({ id, expiresAt: score });\r\n  }\r\n  return results;\r\n}\r\n\r\nasync function redisClear() {\r\n  if (!redisClient) return 0;\r\n  const ids = await redisClient.zrange(REDIS_INDEX_KEY, 0, -1);\r\n  if (ids.length === 0) return 0;\r\n  const keys = ids.map((id: string) => REDIS_KEY_PREFIX + id);\r\n  await redisClient.del(...keys);\r\n  const removed = await redisClient.del(REDIS_INDEX_KEY);\r\n  return ids.length;\r\n}\r\n\r\nfunction cleanupChecksumCache() {\r\n  const now = Date.now();\r\n  for (const [key, entry] of checksumCache.entries()) {\r\n    if (entry.expiresAt <= now) checksumCache.delete(key);\r\n  }\r\n}\r\n// run cleanup periodically for memory fallback\r\nsetInterval(cleanupChecksumCache, 30 * 1000).unref();\r\n\r\n// store checksum: POST /npz/checksum/store { id, checksum, ttlMs? }\r\napp.post('/npz/checksum/store', async (req: any, res: any) => {\r\n  const { id, checksum, ttlMs } = req.body || {};\r\n  if (!id || !checksum) return res.status(400).json({ success: false, error: 'missing id or checksum' });\r\n  const ttl = typeof ttlMs === 'number' && ttlMs > 0 ? ttlMs : CHECKSUM_DEFAULT_TTL_MS;\r\n  if (redisClient) {\r\n    try {\r\n      await redisStore(String(id), String(checksum), ttl);\r\n      audit({ t: Date.now(), event: 'checksum_stored_redis', id: String(id) });\r\n      return res.json({ success: true, id: String(id), ttlMs: ttl, backend: 'redis' });\r\n    } catch (e) {\r\n      // fallback to in-memory\r\n    }\r\n  }\r\n  checksumCache.set(String(id), { checksum: String(checksum), expiresAt: Date.now() + ttl });\r\n  audit({ t: Date.now(), event: 'checksum_stored_mem', id: String(id) });\r\n  return res.json({ success: true, id: String(id), ttlMs: ttl, backend: 'memory' });\r\n});\r\n\r\n// verify checksum: POST /npz/checksum/verify { id, checksum }\r\n// if verified, remove from cache (one-time) and return success\r\napp.post('/npz/checksum/verify', async (req: any, res: any) => {\r\n  const { id, checksum } = req.body || {};\r\n  if (!id || !checksum) return res.status(400).json({ success: false, error: 'missing id or checksum' });\r\n\r\n  if (redisClient) {\r\n    try {\r\n      const rec = await redisGet(String(id));\r\n      if (!rec) return res.status(404).json({ success: false, error: 'checksum not found or expired' });\r\n      if (rec.checksum !== String(checksum)) {\r\n        audit({ t: Date.now(), event: 'checksum_mismatch_redis', id: String(id), provided: String(checksum), expected: rec.checksum });\r\n        return res.status(400).json({ success: false, error: 'checksum mismatch' });\r\n      }\r\n      await redisDelete(String(id));\r\n      audit({ t: Date.now(), event: 'checksum_verified_redis', id: String(id) });\r\n      return res.json({ success: true, id: String(id), backend: 'redis' });\r\n    } catch (e) {\r\n      // fallback to memory\r\n    }\r\n  }\r\n\r\n  const entry = checksumCache.get(String(id));\r\n  if (!entry) return res.status(404).json({ success: false, error: 'checksum not found or expired' });\r\n  if (entry.checksum !== String(checksum)) {\r\n    audit({ t: Date.now(), event: 'checksum_mismatch_mem', id: String(id), provided: String(checksum), expected: entry.checksum });\r\n    return res.status(400).json({ success: false, error: 'checksum mismatch' });\r\n  }\r\n  // match: remove and return success\r\n  checksumCache.delete(String(id));\r\n  audit({ t: Date.now(), event: 'checksum_verified_mem', id: String(id) });\r\n  return res.json({ success: true, id: String(id), backend: 'memory' });\r\n});\r\n\r\n// list checksums: GET /npz/checksum/list\r\napp.get('/npz/checksum/list', async (_req: any, res: any) => {\r\n  if (redisClient) {\r\n    try {\r\n      const items = await redisList();\r\n      const now = Date.now();\r\n      const result = items.map((it: any) => ({ id: it.id, expiresInMs: Math.max(0, it.expiresAt - now) }));\r\n      return res.json({ success: true, count: result.length, items: result, backend: 'redis' });\r\n    } catch (e) {\r\n      // fallback\r\n    }\r\n  }\r\n  const now = Date.now();\r\n  const results: { id: string; expiresInMs: number }[] = [];\r\n  for (const [id, entry] of checksumCache.entries()) {\r\n    results.push({ id, expiresInMs: Math.max(0, entry.expiresAt - now) });\r\n  }\r\n  return res.json({ success: true, count: results.length, items: results, backend: 'memory' });\r\n});\r\n\r\n// clear checksums: DELETE /npz/checksum/clear\r\napp.delete('/npz/checksum/clear', async (_req: any, res: any) => {\r\n  if (redisClient) {\r\n    try {\r\n      const cleared = await redisClear();\r\n      audit({ t: Date.now(), event: 'checksum_cleared_redis', cleared });\r\n      return res.json({ success: true, cleared, backend: 'redis' });\r\n    } catch (e) {\r\n      // fallback\r\n    }\r\n  }\r\n  const cleared = checksumCache.size;\r\n  checksumCache.clear();\r\n  audit({ t: Date.now(), event: 'checksum_cleared_mem', cleared });\r\n  return res.json({ success: true, cleared, backend: 'memory' });\r\n});\r\n\r\napp.post('/license/activate', async (req: any, res: any) => {\r\n  const { key, product_id } = req.body || {};\r\n  if (!key) return res.status(400).json({ success: false, error: 'missing key' });\r\n  audit({ t: Date.now(), action: 'activate_attempt', key: key.replace(/.(?=.{4})/g, '*'), product_id });\r\n\r\n  if (!gumroad || typeof gumroad.activateLicense !== 'function') {\r\n    return res.status(501).json({ success: false, error: 'gumroad helper not available on daemon' });\r\n  }\r\n\r\n  const token = process.env.GUMROAD_TOKEN || '';\r\n  const pid = product_id || process.env.GUMROAD_PRODUCT_ID || process.env.GUMROAD_PRODUCT_YEARLY || process.env.GUMROAD_PRODUCT_MONTHLY || '';\r\n\r\n  try {\r\n    const rec = await gumroad.activateLicense(pid, key, token);\r\n    audit({ t: Date.now(), action: 'activate_success', key: key.replace(/.(?=.{4})/g, '*'), product_id: pid });\r\n    return res.json({ success: true, license: rec });\r\n  } catch (err: any) {\r\n    audit({ t: Date.now(), action: 'activate_failed', err: String(err), product_id: pid });\r\n    return res.status(400).json({ success: false, error: err && err.message ? err.message : String(err) });\r\n  }\r\n});\r\n\r\napp.get('/license/status', (_req: any, res: any) => {\r\n  if (!gumroad || typeof gumroad.loadLicense !== 'function') return res.json({ success: true, license: null });\r\n  const rec = gumroad.loadLicense();\r\n  return res.json({ success: true, license: rec, valid: rec ? gumroad.isLicenseValid(rec) : false });\r\n});\r\n\r\n// public webhook endpoint suggested: /qflush/license/webhook\r\napp.post('/qflush/license/webhook', (req: any, res: any) => {\r\n  const payload = req.body || {};\r\n  audit({ t: Date.now(), event: 'gumroad_webhook', payload });\r\n\r\n  // inspect payload for refund/chargeback/subscription cancel\r\n  const purchase = payload.purchase || payload.data || null;\r\n  let shouldClear = false;\r\n\r\n  if (purchase) {\r\n    if (purchase.refunded || purchase.chargebacked) shouldClear = true;\r\n    if (purchase.subscription_cancelled_at || purchase.subscription_ended_at) shouldClear = true;\r\n  }\r\n\r\n  const ev = (payload.event || payload.type || '').toString().toLowerCase();\r\n  if (ev.includes('refund') || ev.includes('chargeback') || ev.includes('subscription_cancel')) shouldClear = true;\r\n\r\n  if (shouldClear && gumroad && typeof gumroad.clearLicense === 'function') {\r\n    try {\r\n      gumroad.clearLicense();\r\n      audit({ t: Date.now(), event: 'license_cleared_via_webhook' });\r\n    } catch (e) {\r\n      audit({ t: Date.now(), event: 'license_clear_failed', err: String(e) });\r\n    }\r\n  }\r\n\r\n  return res.json({ ok: true });\r\n});\r\n\r\n// legacy webhook path used earlier\r\napp.post('/webhooks/gumroad', (req: any, res: any) => {\r\n  // forward to same handler logic\r\n  return app.handle(req, res);\r\n});\r\n\r\napp.get('/status', (_req: any, res: any) => {\r\n  res.json({ ok: true, port: PORT, checksumCacheSize: checksumCache.size, redis: !!redisClient });\r\n});\r\n\r\n// expose npz pourparler endpoints\r\ntry {\r\n  // eslint-disable-next-line @typescript-eslint/no-var-requires\r\n  const pourparler = require('../utils/npz-pourparler');\r\n\r\n  app.post('/npz/pourparler', (req: any, res: any) => {\r\n    try {\r\n      const body = req.body || {};\r\n      const action = body.action || 'color'; // default action\r\n      const text = String(body.text || '');\r\n\r\n      if (action === 'encode') {\r\n        const enc = pourparler.encodeAscii4(text);\r\n        return res.json({ success: true, encoded: enc });\r\n      }\r\n\r\n      if (action === 'color') {\r\n        const colored = pourparler.colorizeAscii4(text);\r\n        return res.json({ success: true, colored });\r\n      }\r\n\r\n      if (action === 'start') {\r\n        const s = pourparler.startSession(body.systemPrompt || '');\r\n        return res.json({ success: true, session: s });\r\n      }\r\n\r\n      if (action === 'send') {\r\n        if (!body.sessionId) return res.status(400).json({ success: false, error: 'sessionId missing' });\r\n        const m = pourparler.sendMessage(body.sessionId, body.role || 'user', String(body.text || ''));\r\n        return res.json({ success: true, message: m });\r\n      }\r\n\r\n      if (action === 'history') {\r\n        if (!body.sessionId) return res.status(400).json({ success: false, error: 'sessionId missing' });\r\n        const h = pourparler.getHistory(body.sessionId);\r\n        return res.json({ success: true, history: h });\r\n      }\r\n\r\n      if (action === 'end') {\r\n        if (!body.sessionId) return res.status(400).json({ success: false, error: 'sessionId missing' });\r\n        const ok = pourparler.endSession(body.sessionId);\r\n        return res.json({ success: true, ended: ok });\r\n      }\r\n\r\n      if (action === 'checksum') {\r\n        try {\r\n          const cssPath = path.join(process.cwd(), 'extensions', 'vscode-npz', 'pourparler-checksum.css');\r\n            if (fs.existsSync(cssPath)) {\r\n            const content = fs.readFileSync(cssPath, 'utf8');\r\n            // extract the checksum value\r\n            const m = content.match(/--npz-pourparler-checksum:\\s*'([a-f0-9]+)'/i);\r\n            const checksum = m ? m[1] : null;\r\n            return res.json({ success: true, checksum, path: cssPath });\r\n          }\r\n          return res.status(404).json({ success: false, error: 'css not found' });\r\n        } catch (err) {\r\n          return res.status(500).json({ success: false, error: String(err) });\r\n        }\r\n      }\r\n\r\n      return res.status(400).json({ success: false, error: 'unknown action' });\r\n    } catch (e: any) {\r\n      return res.status(500).json({ success: false, error: String(e) });\r\n    }\r\n  });\r\n} catch (e) {\r\n  // ignore if module not present\r\n}\r\n\r\napp.listen(PORT, () => {\r\n  console.log(`qflush running on http://localhost:${PORT}`);\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\qflush\\src\\index.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'m' is defined but never used. Allowed unused args must match /^_/u.","line":28,"column":41,"nodeType":"Identifier","messageId":"unusedVar","endLine":28,"endColumn":42}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\r\nimport { buildPipeline, executePipeline } from \"./chain/smartChain\";\r\nimport { showHelp } from \"./cli/help\";\r\nimport { runCompose } from \"./commands/compose\";\r\nimport { runDoctor } from \"./commands/doctor\";\r\nimport runNpzInspect from \"./commands/npz-inspect\";\r\nimport runNpzScores from \"./commands/npz-scores\";\r\nimport { runLicense } from \"./commands/license\";\r\nimport runChecksum from \"./commands/checksum\";\r\n\r\nconst argv = process.argv.slice(2);\r\nif (argv.includes(\"--help\") || argv.includes(\"-h\")) {\r\n  showHelp();\r\n  process.exit(0);\r\n}\r\n\r\nconst first = argv[0];\r\nif (first === \"compose\") {\r\n  void runCompose(argv.slice(1));\r\n  process.exit(0);\r\n}\r\nif (first === \"doctor\") {\r\n  void runDoctor(argv.slice(1));\r\n  process.exit(0);\r\n}\r\nif (first === \"daemon\") {\r\n  // start qflushd in-process\r\n  void import(\"./daemon/qflushd\").then((m) => {\r\n    // module starts itself and logs\r\n  }).catch((err) => {\r\n    console.error(\"failed to start daemon\", err);\r\n    process.exit(1);\r\n  });\r\n  process.exit(0);\r\n}\r\n\r\nif (first === 'license' || (first === 'lic' && argv[1] === 'activate')) {\r\n  (async () => {\r\n    const code = await runLicense(argv.slice(1));\r\n    process.exit(code ?? 0);\r\n  })();\r\n}\r\n\r\nif (first === 'checksum') {\r\n  (async () => {\r\n    const code = await runChecksum(argv.slice(1));\r\n    process.exit(code ?? 0);\r\n  })();\r\n}\r\n\r\n// NPZ inspect command: `qflush npz:inspect <id>` or `qflush npz inspect <id>`\r\nif (first === \"npz:inspect\" || (first === \"npz\" && argv[1] === \"inspect\")) {\r\n  const id = first === \"npz:inspect\" ? argv[1] : argv[2];\r\n  if (!id) {\r\n    console.error(\"usage: qflush npz:inspect <npz_id>\");\r\n    process.exit(1);\r\n  }\r\n  // run and exit with returned code\r\n  (async () => {\r\n    try {\r\n      const code = await runNpzInspect(id);\r\n      process.exit(code ?? 0);\r\n    } catch (err) {\r\n      console.error(\"npz inspect failed\", err);\r\n      process.exit(1);\r\n    }\r\n  })();\r\n}\r\n\r\nif (first === \"npz:scores\" || (first === \"npz\" && argv[1] === \"scores\")) {\r\n  (async () => {\r\n    try {\r\n      const args = first === \"npz:scores\" ? argv.slice(1) : argv.slice(2);\r\n      const code = await runNpzScores(args);\r\n      process.exit(code ?? 0);\r\n    } catch (err) {\r\n      console.error(\"npz scores failed\", err);\r\n      process.exit(1);\r\n    }\r\n  })();\r\n}\r\n\r\nif (first === \"npz:scores:reset\" || (first === \"npz\" && argv[1] === \"scores:reset\")) {\r\n  (async () => {\r\n    try {\r\n      const code = await runNpzScores([\"--reset\"]);\r\n      process.exit(code ?? 0);\r\n    } catch (err) {\r\n      console.error(\"npz scores reset failed\", err);\r\n      process.exit(1);\r\n    }\r\n  })();\r\n}\r\n\r\nconst { pipeline, options } = buildPipeline(argv);\r\n\r\nexecutePipeline(pipeline, options).catch((err) => {\r\n  console.error(\"qflush: fatal\", err);\r\n  process.exit(1);\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\qflush\\src\\lib\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\qflush\\src\\lib\\npz-engine\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\qflush\\src\\supervisor\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\qflush\\src\\tests\\checksum.test.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: ESLint was configured to run on `<tsconfigRootDir>/src\\tests\\checksum.test.ts` using `parserOptions.project`: <tsconfigRootDir>/tsconfig.eslint.json\nHowever, that TSConfig does not include this file. Either:\n- Change ESLint's list of included files to not include this file\n- Change that TSConfig to include this file\n- Create a new TSConfig that includes this file and include it in your parserOptions.project\nSee the typescript-eslint docs for more info: https://typescript-eslint.io/linting/troubleshooting#i-get-errors-telling-me-eslint-was-configured-to-run--however-that-tsconfig-does-not--none-of-those-tsconfigs-include-this-file","nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import fetch from 'node-fetch';\r\nimport { spawn } from 'child_process';\r\nimport path from 'path';\r\nimport fs from 'fs';\r\n\r\nconst DAEMON_PORT = 4555;\r\nconst DAEMON_URL = `http://localhost:${DAEMON_PORT}`;\r\nlet daemonProc: any = null;\r\n\r\nfunction wait(ms: number) { return new Promise((r) => setTimeout(r, ms)); }\r\n\r\nasync function startDaemon() {\r\n  // build first\r\n  await new Promise<void>((resolve, reject) => {\r\n    const t = spawn(process.execPath, [path.join(process.cwd(), 'node_modules', 'typescript', 'lib', 'tsc.js'), '-p', '.']);\r\n    t.on('close', (code) => code === 0 ? resolve() : reject(new Error('tsc failed')));\r\n  });\r\n  daemonProc = spawn(process.execPath, [path.join(process.cwd(), 'dist', 'daemon', 'qflushd.js')], { env: { ...process.env, QFLUSHD_PORT: String(DAEMON_PORT) }, stdio: 'inherit' });\r\n  await wait(400);\r\n}\r\n\r\nasync function stopDaemon() {\r\n  if (daemonProc) {\r\n    daemonProc.kill();\r\n    daemonProc = null;\r\n    await wait(200);\r\n  }\r\n}\r\n\r\nexport async function runTests() {\r\n  try {\r\n    await startDaemon();\r\n    // store\r\n    let res = await fetch(`${DAEMON_URL}/npz/checksum/store`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ id: 't1', checksum: 'abc', ttlMs: 2000 }) });\r\n    let j = await res.json();\r\n    if (!j.success) throw new Error('store failed');\r\n\r\n    res = await fetch(`${DAEMON_URL}/npz/checksum/list`);\r\n    j = await res.json();\r\n    if (!j.success || j.count === 0) throw new Error('list failed');\r\n\r\n    // verify mismatch\r\n    res = await fetch(`${DAEMON_URL}/npz/checksum/verify`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ id: 't1', checksum: 'wrong' }) });\r\n    if (res.status === 200) throw new Error('mismatch should fail');\r\n\r\n    // verify correct\r\n    res = await fetch(`${DAEMON_URL}/npz/checksum/verify`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ id: 't1', checksum: 'abc' }) });\r\n    j = await res.json();\r\n    if (!j.success) throw new Error('verify failed');\r\n\r\n    // clear\r\n    res = await fetch(`${DAEMON_URL}/npz/checksum/clear`, { method: 'DELETE' });\r\n    j = await res.json();\r\n    if (!j.success) throw new Error('clear failed');\r\n\r\n    console.log('tests PASSED');\r\n  } catch (e) {\r\n    console.error('tests FAILED', e);\r\n    throw e;\r\n  } finally {\r\n    await stopDaemon();\r\n  }\r\n}\r\n\r\nif (require.main === module) {\r\n  runTests().catch((e) => { console.error(e); process.exit(2); });\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\qflush\\src\\tests\\gumroad-license.test.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: ESLint was configured to run on `<tsconfigRootDir>/src\\tests\\gumroad-license.test.ts` using `parserOptions.project`: <tsconfigRootDir>/tsconfig.eslint.json\nHowever, that TSConfig does not include this file. Either:\n- Change ESLint's list of included files to not include this file\n- Change that TSConfig to include this file\n- Create a new TSConfig that includes this file and include it in your parserOptions.project\nSee the typescript-eslint docs for more info: https://typescript-eslint.io/linting/troubleshooting#i-get-errors-telling-me-eslint-was-configured-to-run--however-that-tsconfig-does-not--none-of-those-tsconfigs-include-this-file","nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { saveLicense, loadLicense, clearLicense } from '../utils/gumroad-license';\r\nimport fs from 'fs';\r\nimport path from 'path';\r\n\r\nconst TMP = path.join(process.cwd(), '.qflush-test', 'license.json');\r\n\r\ndescribe('gumroad-license save/load/clear', () => {\r\n  beforeAll(() => {\r\n    process.env.GUMROAD_LICENSE_PATH = TMP;\r\n    try { if (fs.existsSync(TMP)) fs.unlinkSync(TMP); } catch {}\r\n  });\r\n\r\n  afterAll(() => {\r\n    try { if (fs.existsSync(TMP)) fs.unlinkSync(TMP); } catch {}\r\n  });\r\n\r\n  test('save and load', () => {\r\n    const rec = { key: 'ABC', product_id: 'P1', createdAt: Date.now() } as any;\r\n    saveLicense(rec);\r\n    const loaded = loadLicense();\r\n    expect(loaded).not.toBeNull();\r\n    expect(loaded!.key).toBe('ABC');\r\n  });\r\n\r\n  test('clear', () => {\r\n    clearLicense();\r\n    const loaded = loadLicense();\r\n    expect(loaded).toBeNull();\r\n  });\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\qflush\\src\\tests\\smartchain.test.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: ESLint was configured to run on `<tsconfigRootDir>/src\\tests\\smartchain.test.ts` using `parserOptions.project`: <tsconfigRootDir>/tsconfig.eslint.json\nHowever, that TSConfig does not include this file. Either:\n- Change ESLint's list of included files to not include this file\n- Change that TSConfig to include this file\n- Create a new TSConfig that includes this file and include it in your parserOptions.project\nSee the typescript-eslint docs for more info: https://typescript-eslint.io/linting/troubleshooting#i-get-errors-telling-me-eslint-was-configured-to-run--however-that-tsconfig-does-not--none-of-those-tsconfigs-include-this-file","nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { buildPipeline } from \"../chain/smartChain\";\r\n\r\nfunction assertEqual(a: any, b: any, msg?: string) {\r\n  if (JSON.stringify(a) !== JSON.stringify(b)) throw new Error(msg || `Assertion failed: ${JSON.stringify(a)} !== ${JSON.stringify(b)}`);\r\n}\r\n\r\nfunction runTests() {\r\n  assertEqual(buildPipeline([\"start\"]).pipeline, [\"detect\",\"config\",\"start\"]);\r\n  assertEqual(buildPipeline([\"kill\",\"start\"]).pipeline, [\"kill\",\"detect\",\"config\",\"start\"]);\r\n  assertEqual(buildPipeline([\"purge\",\"start\"]).pipeline, [\"detect\",\"config\",\"purge\",\"start\"]);\r\n  assertEqual(buildPipeline([\"config\",\"start\",\"detect\"]).pipeline, [\"detect\",\"config\",\"start\"]);\r\n  assertEqual(buildPipeline([\"exodia\",\"start\"]).pipeline, [\"detect\",\"config\",\"start\",\"exodia\"]);\r\n  console.log(\"SmartChain tests passed\");\r\n}\r\n\r\nrunTests();\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\qflush\\src\\types\\js-yaml.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\qflush\\src\\types\\shims.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\qflush\\src\\types\\tail.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\qflush\\src\\types\\third-party.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\qflush\\src\\utils\\auth.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\qflush\\src\\utils\\colors.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'prefer' is assigned a value but never used.","line":67,"column":58,"nodeType":"Identifier","messageId":"unusedVar","endLine":67,"endColumn":64}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Utilities for Nezlephant color palette and helpers\r\n// Base color shorthand '0c8' -> #00cc88\r\n\r\nexport const NEZLEPHANT = {\r\n  baseHex: '#00cc88', // shorthand 0c8\r\n  jokerHex: '#ff00cc', // Joker accent (magenta-pink)\r\n  neutralHex: '#0f1724', // dark neutral\r\n  whiteHex: '#ffffff',\r\n  blackHex: '#000000',\r\n};\r\n\r\nfunction clamp(v: number, a = 0, b = 255) {\r\n  return Math.max(a, Math.min(b, Math.round(v)));\r\n}\r\n\r\nexport function hexToRgb(hex: string): { r: number; g: number; b: number } {\r\n  const h = hex.replace('#', '');\r\n  if (h.length === 3) {\r\n    const r = parseInt(h[0] + h[0], 16);\r\n    const g = parseInt(h[1] + h[1], 16);\r\n    const b = parseInt(h[2] + h[2], 16);\r\n    return { r, g, b };\r\n  }\r\n  const r = parseInt(h.slice(0, 2), 16);\r\n  const g = parseInt(h.slice(2, 4), 16);\r\n  const b = parseInt(h.slice(4, 6), 16);\r\n  return { r, g, b };\r\n}\r\n\r\nexport function rgbToHex(r: number, g: number, b: number): string {\r\n  return `#${[r, g, b].map((n) => clamp(n).toString(16).padStart(2, '0')).join('')}`;\r\n}\r\n\r\nexport function rgba(hex: string, alpha = 1): string {\r\n  const { r, g, b } = hexToRgb(hex);\r\n  return `rgba(${r}, ${g}, ${b}, ${alpha})`;\r\n}\r\n\r\nexport function lighten(hex: string, percent = 0.1): string {\r\n  const { r, g, b } = hexToRgb(hex);\r\n  const nr = clamp(r + (255 - r) * percent);\r\n  const ng = clamp(g + (255 - g) * percent);\r\n  const nb = clamp(b + (255 - b) * percent);\r\n  return rgbToHex(nr, ng, nb);\r\n}\r\n\r\nexport function darken(hex: string, percent = 0.1): string {\r\n  const { r, g, b } = hexToRgb(hex);\r\n  const nr = clamp(r * (1 - percent));\r\n  const ng = clamp(g * (1 - percent));\r\n  const nb = clamp(b * (1 - percent));\r\n  return rgbToHex(nr, ng, nb);\r\n}\r\n\r\nexport function relativeLuminance(hex: string): number {\r\n  const { r, g, b } = hexToRgb(hex);\r\n  const srgb = [r / 255, g / 255, b / 255].map((c) => (c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4)));\r\n  return 0.2126 * srgb[0] + 0.7152 * srgb[1] + 0.0722 * srgb[2];\r\n}\r\n\r\nexport function contrastRatio(hexA: string, hexB: string): number {\r\n  const L1 = relativeLuminance(hexA) + 0.05;\r\n  const L2 = relativeLuminance(hexB) + 0.05;\r\n  return Math.max(L1, L2) / Math.min(L1, L2);\r\n}\r\n\r\nexport function readableTextColor(backgroundHex: string, prefer = NEZLEPHANT.whiteHex): string {\r\n  // return white or black depending on contrast\r\n  const whiteContrast = contrastRatio(backgroundHex, NEZLEPHANT.whiteHex);\r\n  const blackContrast = contrastRatio(backgroundHex, NEZLEPHANT.blackHex);\r\n  return whiteContrast >= blackContrast ? NEZLEPHANT.whiteHex : NEZLEPHANT.blackHex;\r\n}\r\n\r\nexport function cssVariables(prefix = 'nez') {\r\n  const base = NEZLEPHANT.baseHex;\r\n  const j = NEZLEPHANT.jokerHex;\r\n  return `:root {\\n  --${prefix}-base: ${base};\\n  --${prefix}-base-90: ${rgba(base, 0.9)};\\n  --${prefix}-base-80: ${rgba(base, 0.8)};\\n  --${prefix}-base-60: ${rgba(base, 0.6)};\\n  --${prefix}-base-30: ${rgba(base, 0.3)};\\n  --${prefix}-light: ${lighten(base, 0.18)};\\n  --${prefix}-dark: ${darken(base, 0.18)};\\n  --${prefix}-joker: ${j};\\n  --${prefix}-bg: ${NEZLEPHANT.neutralHex};\\n  --${prefix}-text: ${readableTextColor(NEZLEPHANT.neutralHex)};\\n}`;\r\n}\r\n\r\n// Terminal ANSI truecolor helpers (supports modern terminals)\r\nexport function ansiFg(hex: string): string {\r\n  const { r, g, b } = hexToRgb(hex);\r\n  return `\\x1b[38;2;${r};${g};${b}m`;\r\n}\r\nexport function ansiBg(hex: string): string {\r\n  const { r, g, b } = hexToRgb(hex);\r\n  return `\\x1b[48;2;${r};${g};${b}m`;\r\n}\r\nexport const ansiReset = '\\x1b[0m';\r\n\r\n// Preset styled log helpers for Joker + Nezlephant\r\nexport function styledLog(title: string, msg: string, opts?: { accent?: 'joker' | 'base' | 'neutral' }) {\r\n  const accent = opts?.accent === 'joker' ? NEZLEPHANT.jokerHex : opts?.accent === 'neutral' ? NEZLEPHANT.neutralHex : NEZLEPHANT.baseHex;\r\n  const bg = ansiBg(darken(accent, 0.15));\r\n  const fg = ansiFg(readableTextColor(darken(accent, 0.15)));\r\n  const accentFg = ansiFg(accent);\r\n  process.stdout.write(`${bg}${fg} [${title}] ${ansiReset} ${accentFg}${msg}${ansiReset}\\n`);\r\n}\r\n\r\nexport default {\r\n  NEZLEPHANT,\r\n  hexToRgb,\r\n  rgbToHex,\r\n  rgba,\r\n  lighten,\r\n  darken,\r\n  readableTextColor,\r\n  cssVariables,\r\n  ansiFg,\r\n  ansiBg,\r\n  ansiReset,\r\n  styledLog,\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\qflush\\src\\utils\\detect.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'err' is defined but never used. Allowed unused args must match /^_/u.","line":52,"column":43,"nodeType":"Identifier","messageId":"unusedVar","endLine":52,"endColumn":46},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'err' is defined but never used. Allowed unused args must match /^_/u.","line":54,"column":32,"nodeType":"Identifier","messageId":"unusedVar","endLine":54,"endColumn":35}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { exec } from \"child_process\";\r\nimport { logger } from \"./logger\";\r\nimport { SERVICE_MAP } from \"./paths\";\r\nimport { resolvePackagePath } from \"./package\";\r\n\r\nexport async function detectModules() {\r\n  const out: Record<string, any> = {};\r\n  for (const name of Object.keys(SERVICE_MAP))\r\n    out[name] = { running: false, installed: false, path: undefined, bin: undefined };\r\n\r\n  for (const name of Object.keys(SERVICE_MAP)) {\r\n    try {\r\n      const pkgPath = resolvePackagePath(SERVICE_MAP[name].pkg);\r\n      if (pkgPath) {\r\n        out[name].installed = true;\r\n        out[name].path = pkgPath;\r\n        try {\r\n          const pkgJson = require(require('path').join(pkgPath, 'package.json'));\r\n          if (pkgJson && pkgJson.bin) {\r\n            out[name].bin = typeof pkgJson.bin === 'string' ? pkgJson.bin : Object.values(pkgJson.bin)[0];\r\n          }\r\n        } catch {}\r\n      }\r\n    } catch {}\r\n  }\r\n\r\n  await new Promise<void>((resolve) => {\r\n    exec(process.platform === \"win32\" ? \"tasklist\" : \"ps aux\", (err, stdout) => {\r\n      if (err) {\r\n        logger.warn(`Failed to list processes: ${err.message}`);\r\n        return resolve();\r\n      }\r\n      const s = stdout.toString();\r\n      for (const name of Object.keys(SERVICE_MAP)) {\r\n        const regex = new RegExp(name, \"i\");\r\n        if (regex.test(s)) {\r\n          out[name].running = true;\r\n        }\r\n      }\r\n      resolve();\r\n    });\r\n  });\r\n  return out;\r\n}\r\n\r\nexport async function findAndKill() {\r\n  const names = Object.keys(SERVICE_MAP);\r\n  const killed: number[] = [];\r\n  for (const n of names) {\r\n    try {\r\n      if (process.platform === \"win32\") {\r\n        exec(`taskkill /IM ${n}.exe /F`, (err) => {});\r\n      } else {\r\n        exec(`pkill -f ${n}`, (err) => {});\r\n      }\r\n    } catch (err) {\r\n      // ignore\r\n    }\r\n  }\r\n  return killed;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\qflush\\src\\utils\\exec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\qflush\\src\\utils\\gumroad-license.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\qflush\\src\\utils\\health.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'logger' is defined but never used.","line":3,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":16}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import http from 'http';\r\nimport net from 'net';\r\nimport { logger } from './logger';\r\n\r\nexport async function httpProbe(url: string, timeout = 2000): Promise<boolean> {\r\n  return new Promise((resolve) => {\r\n    const req = http.get(url, (res) => {\r\n      res.resume();\r\n      resolve(Boolean(res.statusCode && res.statusCode < 400));\r\n    });\r\n    req.on('error', () => resolve(false));\r\n    req.setTimeout(timeout, () => {\r\n      req.destroy();\r\n      resolve(false);\r\n    });\r\n  });\r\n}\r\n\r\nexport async function tcpProbe(host: string, port: number, timeout = 2000): Promise<boolean> {\r\n  return new Promise((resolve) => {\r\n    const s = new net.Socket();\r\n    let done = false;\r\n    s.setTimeout(timeout);\r\n    s.on('connect', () => {\r\n      done = true;\r\n      s.destroy();\r\n      resolve(true);\r\n    });\r\n    s.on('error', () => { if (!done) { done = true; resolve(false); } });\r\n    s.on('timeout', () => { if (!done) { done = true; s.destroy(); resolve(false); } });\r\n    s.connect(port, host);\r\n  });\r\n}\r\n\r\nexport async function waitForService(urlOrHost: string, port?: number, timeout = 5000) {\r\n  const start = Date.now();\r\n  while (Date.now() - start < timeout) {\r\n    let ok = false;\r\n    if (typeof port === 'number') {\r\n      ok = await tcpProbe(urlOrHost, port, 1000);\r\n    } else if (urlOrHost.startsWith('http')) {\r\n      ok = await httpProbe(urlOrHost, 1000);\r\n    }\r\n    if (ok) return true;\r\n    await new Promise((r) => setTimeout(r, 500));\r\n  }\r\n  return false;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\qflush\\src\\utils\\license.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\qflush\\src\\utils\\logger.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\qflush\\src\\utils\\npz-admin.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\qflush\\src\\utils\\npz-config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\qflush\\src\\utils\\npz-customs.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\qflush\\src\\utils\\npz-engine.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'logger' is defined but never used.","line":4,"column":8,"nodeType":"Identifier","messageId":"unusedVar","endLine":4,"endColumn":14}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { getNpzNamespace } from './npz-config';\r\nimport fs from 'fs';\r\nimport path from 'path';\r\nimport logger from './logger';\r\nimport { Lane } from './npz-router';\r\n\r\nconst NS = getNpzNamespace();\r\nconst ENGINE_FILE = path.join(process.cwd(), '.qflush', `${NS}-npz-engine.json`);\r\n\r\ntype ScoreRecord = {\r\n  laneId: number;\r\n  score: number; // lower is better\r\n  lastSuccess?: number;\r\n  lastFailure?: number;\r\n};\r\n\r\ntype EngineStore = Record<number, ScoreRecord>;\r\n\r\nlet store: EngineStore = {};\r\n\r\n// decay parameters\r\nconst DECAY_INTERVAL_MS = 60 * 1000; // every minute\r\nconst DECAY_FACTOR = 0.9; // multiply score by this every decay interval (towards 0)\r\n\r\nfunction ensureDir() {\r\n  const dir = path.dirname(ENGINE_FILE);\r\n  if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });\r\n}\r\n\r\nfunction load() {\r\n  try {\r\n    if (fs.existsSync(ENGINE_FILE)) {\r\n      const raw = fs.readFileSync(ENGINE_FILE, 'utf8');\r\n      store = JSON.parse(raw) as EngineStore;\r\n    }\r\n  } catch (e) {\r\n    store = {};\r\n  }\r\n}\r\n\r\nfunction persist() {\r\n  try {\r\n    ensureDir();\r\n    fs.writeFileSync(ENGINE_FILE, JSON.stringify(store, null, 2), 'utf8');\r\n  } catch (e) {}\r\n}\r\n\r\nfunction applyDecay() {\r\n  const now = Date.now();\r\n  let changed = false;\r\n  for (const k of Object.keys(store)) {\r\n    const id = Number(k);\r\n    const rec = store[id];\r\n    if (!rec) continue;\r\n    // compute how many intervals since lastSuccess/lastFailure (use lastFailure as activity reference)\r\n    const ref = rec.lastFailure || rec.lastSuccess || now;\r\n    const intervals = Math.floor((now - ref) / DECAY_INTERVAL_MS);\r\n    if (intervals <= 0) continue;\r\n    const factor = Math.pow(DECAY_FACTOR, intervals);\r\n    const newScore = rec.score * factor;\r\n    if (Math.abs(newScore - rec.score) > 1e-6) {\r\n      rec.score = newScore;\r\n      changed = true;\r\n    }\r\n  }\r\n  if (changed) persist();\r\n}\r\n\r\nload();\r\n\r\n// schedule periodic decay in-memory (best-effort)\r\nsetInterval(() => {\r\n  try { applyDecay(); } catch (e) {}\r\n}, DECAY_INTERVAL_MS);\r\n\r\n/**\r\n * Adjust lane score.\r\n * delta: positive increases penalty (worse), negative decreases (better).\r\n * latencyMs: optional latency observed to weight the delta.\r\n */\r\nexport function scoreLane(laneId: number, delta: number, latencyMs?: number) {\r\n  let rec = store[laneId];\r\n  if (!rec) rec = { laneId, score: 0 };\r\n  // weight delta by latency (if provided): normalized over 1000ms\r\n  let weight = 1;\r\n  if (latencyMs && latencyMs > 0) weight += Math.min(5, latencyMs / 1000); // cap weight\r\n  rec.score = (rec.score || 0) + delta * weight;\r\n  if (delta < 0) rec.lastSuccess = Date.now();\r\n  if (delta > 0) rec.lastFailure = Date.now();\r\n  store[laneId] = rec;\r\n  persist();\r\n}\r\n\r\nexport function getLaneScore(laneId: number) {\r\n  const rec = store[laneId];\r\n  if (!rec) return 0;\r\n  // apply decay relative to now on read (non-persistent)\r\n  const now = Date.now();\r\n  const ref = rec.lastFailure || rec.lastSuccess || now;\r\n  const intervals = Math.floor((now - ref) / DECAY_INTERVAL_MS);\r\n  const factor = Math.pow(DECAY_FACTOR, intervals);\r\n  return rec.score * factor;\r\n}\r\n\r\nexport function orderLanesByScore(lanes: Lane[]) {\r\n  // return copy sorted by score asc\r\n  const out = lanes.slice();\r\n  out.sort((a, b) => getLaneScore(a.id) - getLaneScore(b.id));\r\n  return out;\r\n}\r\n\r\nexport function resetScores() {\r\n  store = {};\r\n  persist();\r\n}\r\n\r\nexport function getStore() {\r\n  return store;\r\n}\r\n\r\nexport default { scoreLane, getLaneScore, orderLanesByScore, resetScores, getStore };\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\qflush\\src\\utils\\npz-metrics.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\qflush\\src\\utils\\npz-middleware.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'npz' is defined but never used.","line":5,"column":8,"nodeType":"Identifier","messageId":"unusedVar","endLine":5,"endColumn":11},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'lanes' is assigned a value but never used.","line":25,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":25,"endColumn":14}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response, NextFunction } from 'express';\r\nimport { v4 as uuidv4 } from 'uuid';\r\nimport { npzRoute } from './npz-router';\r\nimport npzStore from './npz-store';\r\nimport npz from './npz';\r\nimport logger from './logger';\r\nimport client from 'prom-client';\r\nimport { getNpzNamespace } from './npz-config';\r\n\r\nconst NS = getNpzNamespace();\r\nconst requestDuration = new client.Histogram({\r\n  name: `${NS}_request_duration_seconds`,\r\n  help: 'Duration of NPZ handled requests',\r\n  labelNames: ['gate', 'lane', 'npz_id', 'namespace'] as string[],\r\n});\r\n\r\nexport type NpzMiddlewareOptions = {\r\n  lanes?: any[];\r\n  cookieName?: string;\r\n  cookieMaxAge?: number;\r\n};\r\n\r\nexport function npzMiddleware(opts: NpzMiddlewareOptions = {}) {\r\n  const cookieName = opts.cookieName || `${NS}_lane`;\r\n  const lanes = opts.lanes || undefined;\r\n  const maxAge = opts.cookieMaxAge || 24 * 3600; // seconds\r\n\r\n  return async function (req: Request, res: Response, next: NextFunction) {\r\n    const start = process.hrtime();\r\n    try {\r\n      // assign npz_id\r\n      const npz_id = (req.headers['x-npz-id'] as string) || req.cookies?.['npz_id'] || uuidv4();\r\n      res.cookie('npz_id', npz_id, { maxAge: maxAge * 1000, httpOnly: true });\r\n      await npzStore.createRequestRecord(npz_id, { path: req.path, method: req.method });\r\n\r\n      const fullUrl = req.protocol + '://' + req.get('host') + req.originalUrl;\r\n\r\n      const report = await npzRoute({ method: req.method, url: fullUrl, headers: req.headers as any, body: (req as any).body });\r\n\r\n      if (report && (report.status || report.body || report.error)) {\r\n        // update record with lane if stored via router\r\n        const rec = await npzStore.getRequestRecord(npz_id);\r\n        const lane = rec?.laneId;\r\n        if (lane !== undefined) {\r\n          res.cookie(cookieName, String(lane), { maxAge: maxAge * 1000 });\r\n        }\r\n\r\n        // metrics\r\n        const diff = process.hrtime(start);\r\n        const duration = diff[0] + diff[1] / 1e9;\r\n        const gate = (report as any).gate || 'unknown';\r\n        const laneId = (report as any).laneId !== undefined ? String((report as any).laneId) : String(lane || 'unknown');\r\n        requestDuration.labels(gate, laneId, npz_id, NS).observe(duration);\r\n\r\n        logger.nez('NPZ', `npz_id=${npz_id} gate=${gate} lane=${laneId} duration=${duration.toFixed(3)}s`);\r\n\r\n        if (report.status) res.status(report.status);\r\n        // set headers (careful with set-cookie)\r\n        if (report.headers) {\r\n          try {\r\n            for (const [k, v] of Object.entries(report.headers)) {\r\n              if (k.toLowerCase() === 'set-cookie') continue;\r\n              res.setHeader(k, v as any);\r\n            }\r\n          } catch (e) {}\r\n        }\r\n        res.send(report.body || (report.error ? String((report as any).error) : ''));\r\n        return;\r\n      }\r\n\r\n      next();\r\n    } catch (err) {\r\n      logger.warn(`npz-middleware: error ${err}`);\r\n      next();\r\n    }\r\n  };\r\n}\r\n\r\nexport default npzMiddleware;\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\qflush\\src\\utils\\npz-pourparler.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'hexToRgb' is defined but never used.","line":53,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":53,"endColumn":18}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import crypto from 'crypto';\r\n\r\ntype Message = { id: string; role: 'user' | 'assistant' | 'system'; text: string; t: number };\r\n\r\ntype Session = { id: string; messages: Message[]; createdAt: number };\r\n\r\nconst SESSIONS: Map<string, Session> = new Map();\r\n\r\nfunction id() { return Math.random().toString(36).slice(2,10); }\r\n\r\nexport function startSession(systemPrompt = ''): Session {\r\n  const sid = 's_' + id();\r\n  const s: Session = { id: sid, messages: [], createdAt: Date.now() };\r\n  if (systemPrompt) s.messages.push({ id: 'm_' + id(), role: 'system', text: systemPrompt, t: Date.now() });\r\n  SESSIONS.set(sid, s);\r\n  return s;\r\n}\r\n\r\nexport function sendMessage(sessionId: string, role: 'user' | 'assistant' | 'system', text: string) {\r\n  const s = SESSIONS.get(sessionId);\r\n  if (!s) throw new Error('session not found');\r\n  const m: Message = { id: 'm_' + id(), role, text, t: Date.now() };\r\n  s.messages.push(m);\r\n  return m;\r\n}\r\n\r\nexport function getHistory(sessionId: string) {\r\n  const s = SESSIONS.get(sessionId);\r\n  if (!s) return [] as Message[];\r\n  return s.messages.slice();\r\n}\r\n\r\nexport function endSession(sessionId: string) {\r\n  return SESSIONS.delete(sessionId);\r\n}\r\n\r\n// --- New: ASCII 4-byte encoding + colorize helpers ---\r\n\r\nfunction md5First4BytesHex(ch: string): string {\r\n  // return first 4 bytes (8 hex chars) of md5 of the char\r\n  const h = crypto.createHash('md5').update(ch).digest('hex');\r\n  return h.slice(0, 8);\r\n}\r\n\r\nexport function encodeAscii4(text: string): { ch: string; hex4: string }[] {\r\n  const out: { ch: string; hex4: string }[] = [];\r\n  for (const ch of text) {\r\n    out.push({ ch, hex4: md5First4BytesHex(ch) });\r\n  }\r\n  return out;\r\n}\r\n\r\nfunction hexToRgb(hex: string) {\r\n  const h = hex.replace('#', '');\r\n  const r = parseInt(h.slice(0, 2), 16);\r\n  const g = parseInt(h.slice(2, 4), 16);\r\n  const b = parseInt(h.slice(4, 6), 16);\r\n  return { r, g, b };\r\n}\r\n\r\nfunction byteToColor(b: number) {\r\n  // map single byte [0..255] to a color by expanding into RGB via simple transform\r\n  const r = (b * 3) % 256;\r\n  const g = (b * 7) % 256;\r\n  const b2 = (b * 13) % 256;\r\n  return { r, g, b: b2 };\r\n}\r\n\r\nexport function colorizeAscii4(text: string): string {\r\n  // returns ANSI colored string: for each char produce a colored block based on its 4-byte hex\r\n  const parts: string[] = [];\r\n  for (const ch of text) {\r\n    const hex4 = md5First4BytesHex(ch); // 8 hex chars\r\n    // split into 4 bytes\r\n    const bytes: number[] = [];\r\n    for (let i = 0; i < 8; i += 2) bytes.push(parseInt(hex4.slice(i, i+2), 16));\r\n    // pick a representative color from bytes\r\n    const col = byteToColor(bytes[0]);\r\n    const ansi = `\\x1b[48;2;${col.r};${col.g};${col.b}m\\x1b[38;2;0;0;0m ${ch} \\x1b[0m`;\r\n    parts.push(ansi);\r\n  }\r\n  return parts.join('');\r\n}\r\n\r\nexport default { startSession, sendMessage, getHistory, endSession, encodeAscii4, colorizeAscii4 };\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\qflush\\src\\utils\\npz-router.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'lanes' is assigned a value but never used.","line":177,"column":49,"nodeType":"Identifier","messageId":"unusedVar","endLine":177,"endColumn":62}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import fs from 'fs';\r\nimport path from 'path';\r\nimport { performance } from 'perf_hooks';\r\nimport logger from './logger';\r\nimport client from 'prom-client';\r\nimport { getNpzNamespace } from './npz-config';\r\nimport engine from './npz-engine';\r\n\r\nconst NS = getNpzNamespace();\r\n\r\nexport type Lane = { id: number; name: string; url: string };\r\n\r\nexport const DEFAULT_LANES: Lane[] = [\r\n  { id: 0, name: 'primary', url: 'https://api.primary.local' },\r\n  { id: 1, name: 'backup-fast', url: 'https://fast.api.local' },\r\n  { id: 2, name: 'backup-slow', url: 'https://slow.api.local' },\r\n];\r\n\r\nconst STORE_FILE = path.join(process.cwd(), '.qflush', `${NS}-npz-lanes.json`);\r\nconst DEFAULT_TIMEOUT = 3000; // ms\r\nconst PREFERRED_TTL = 24 * 3600 * 1000; // 24h\r\n\r\n// Circuit breaker settings\r\nconst FAIL_THRESHOLD = 3; // failures\r\nconst FAIL_WINDOW_MS = 60 * 1000; // 1m\r\nconst COOLDOWN_MS = 5 * 60 * 1000; // 5m\r\n\r\ntype Store = Record<string, { laneId: number; ts: number }>;\r\n\r\ntype CircuitState = {\r\n  failures: number;\r\n  firstFailureTs?: number;\r\n  trippedUntil?: number;\r\n};\r\n\r\nconst circuit: Map<string, Map<number, CircuitState>> = new Map(); // host -> laneId -> state\r\n\r\n// Prometheus metrics\r\nconst laneSuccess = new client.Counter({ name: `${NS}_lane_success_total`, help: 'NPZ lane successes', labelNames: ['host', 'lane', 'namespace'] });\r\nconst laneFailure = new client.Counter({ name: `${NS}_lane_failure_total`, help: 'NPZ lane failures', labelNames: ['host', 'lane', 'namespace'] });\r\n\r\nfunction ensureStoreDir() {\r\n  const dir = path.dirname(STORE_FILE);\r\n  if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });\r\n}\r\n\r\nfunction readStore(): Store {\r\n  try {\r\n    if (!fs.existsSync(STORE_FILE)) return {};\r\n    const raw = fs.readFileSync(STORE_FILE, 'utf8');\r\n    return JSON.parse(raw) as Store;\r\n  } catch (err) {\r\n    logger.warn(`npz-router: failed to read store ${err}`);\r\n    return {};\r\n  }\r\n}\r\n\r\nfunction writeStore(s: Store) {\r\n  try {\r\n    ensureStoreDir();\r\n    fs.writeFileSync(STORE_FILE, JSON.stringify(s, null, 2), 'utf8');\r\n  } catch (err) {\r\n    logger.warn(`npz-router: failed to write store ${err}`);\r\n  }\r\n}\r\n\r\nexport function getPreferredLane(host: string): number | null {\r\n  const s = readStore();\r\n  const entry = s[host];\r\n  if (!entry) return null;\r\n  if (Date.now() - entry.ts > PREFERRED_TTL) return null;\r\n  return entry.laneId;\r\n}\r\n\r\nexport function setPreferredLane(host: string, laneId: number) {\r\n  const s = readStore();\r\n  s[host] = { laneId, ts: Date.now() };\r\n  writeStore(s);\r\n}\r\n\r\nexport function lanesForHost(host: string, lanes: Lane[] = DEFAULT_LANES): Lane[] {\r\n  const pref = getPreferredLane(host);\r\n  // first let engine reorder by score\r\n  const ordered = engine.orderLanesByScore(lanes);\r\n  // then apply preferred lane override\r\n  if (pref === null) return ordered.slice();\r\n  const idx = ordered.findIndex((l) => l.id === pref);\r\n  if (idx <= 0) return ordered.slice();\r\n  const res = [ordered[idx], ...ordered.slice(0, idx), ...ordered.slice(idx + 1)];\r\n  return res;\r\n}\r\n\r\n// Circuit breaker helpers\r\nfunction getCircuitMapForHost(host: string) {\r\n  let m = circuit.get(host);\r\n  if (!m) {\r\n    m = new Map();\r\n    circuit.set(host, m);\r\n  }\r\n  return m;\r\n}\r\n\r\nexport function recordFailure(host: string, laneId: number, latencyMs?: number) {\r\n  const m = getCircuitMapForHost(host);\r\n  const now = Date.now();\r\n  const st = m.get(laneId) || { failures: 0 };\r\n  if (!st.firstFailureTs || now - (st.firstFailureTs || 0) > FAIL_WINDOW_MS) {\r\n    st.failures = 1;\r\n    st.firstFailureTs = now;\r\n  } else {\r\n    st.failures = (st.failures || 0) + 1;\r\n  }\r\n  if (st.failures >= FAIL_THRESHOLD) {\r\n    st.trippedUntil = now + COOLDOWN_MS;\r\n    logger.warn(`npz-router: lane ${laneId} for ${host} tripped until ${new Date(st.trippedUntil)}`);\r\n  }\r\n  m.set(laneId, st);\r\n  try { laneFailure.inc({ host, lane: String(laneId), namespace: NS } as any); } catch {}\r\n  try { engine.scoreLane(laneId, 1, latencyMs); } catch {}\r\n}\r\n\r\nexport function recordSuccess(host: string, laneId: number, latencyMs?: number) {\r\n  const m = getCircuitMapForHost(host);\r\n  m.delete(laneId);\r\n  try { laneSuccess.inc({ host, lane: String(laneId), namespace: NS } as any); } catch {}\r\n  try { engine.scoreLane(laneId, -1, latencyMs); } catch {}\r\n}\r\n\r\nexport function isLaneTripped(host: string, laneId: number): boolean {\r\n  const m = circuit.get(host);\r\n  if (!m) return false;\r\n  const st = m.get(laneId);\r\n  if (!st) return false;\r\n  if (st.trippedUntil && Date.now() < st.trippedUntil) return true;\r\n  // cooldown passed\r\n  if (st.trippedUntil && Date.now() >= st.trippedUntil) {\r\n    m.delete(laneId);\r\n    return false;\r\n  }\r\n  return false;\r\n}\r\n\r\n// lightweight fetch wrapper that returns {status, headers, body, durationMs}\r\nasync function tryFetch(fullUrl: string, options: any = {}, timeout = DEFAULT_TIMEOUT) {\r\n  const controller = typeof AbortController !== 'undefined' ? new AbortController() : null;\r\n  const signalOpt = controller ? { signal: controller.signal } : {};\r\n  const opts = { method: options.method || 'GET', headers: options.headers || {}, body: options.body, ...signalOpt };\r\n  let timer: NodeJS.Timeout | null = null;\r\n  const start = performance.now();\r\n  if (controller) timer = setTimeout(() => controller.abort(), timeout);\r\n  try {\r\n    // prefer global fetch\r\n    let ff: any = (globalThis as any).fetch;\r\n    if (!ff) {\r\n      try {\r\n        // eslint-disable-next-line @typescript-eslint/no-var-requires\r\n        ff = require('undici').fetch;\r\n      } catch (e) {\r\n        throw new Error('No fetch available (install undici or use Node 18+)');\r\n      }\r\n    }\r\n    const res = await ff(fullUrl, opts);\r\n    const text = await res.text();\r\n    if (timer) clearTimeout(timer);\r\n    const duration = Math.max(0, Math.round(performance.now() - start));\r\n    return { ok: true, status: res.status, headers: res.headers, body: text, durationMs: duration };\r\n  } catch (err: any) {\r\n    if (timer) clearTimeout(timer);\r\n    const duration = Math.max(0, Math.round(performance.now() - start));\r\n    return { ok: false, error: err, durationMs: duration };\r\n  }\r\n}\r\n\r\nexport type NpzRequest = { method?: string; url: string; headers?: Record<string, string>; body?: any; timeout?: number };\r\nexport type NpzResponse = { status?: number; headers?: any; body?: string; error?: any; gate?: string; laneId?: number; durationMs?: number };\r\n\r\nexport async function npzRoute(req: NpzRequest, lanes: Lane[] = DEFAULT_LANES): Promise<NpzResponse> {\r\n  try {\r\n    const urlObj = new URL(req.url);\r\n    const host = urlObj.host;\r\n    const ordered = lanesForHost(host) as Lane[];\r\n\r\n    // attempt primary\r\n    const primary = ordered[0];\r\n    const primaryUrl = req.url.replace(urlObj.origin, primary.url);\r\n    const timeout = req.timeout || DEFAULT_TIMEOUT;\r\n\r\n    logger.nez('NPZ', `attempting primary lane ${primary.name} -> ${primaryUrl}`);\r\n    const t0 = await tryFetch(primaryUrl, { method: req.method, headers: req.headers, body: req.body }, timeout);\r\n\r\n    if (t0.ok && t0.status && t0.status < 500) {\r\n      logger.nez('NPZ', `primary succeeded (${primary.name})`);\r\n      setPreferredLane(host, primary.id);\r\n      recordSuccess(host, primary.id, t0.durationMs);\r\n      return { status: t0.status, headers: t0.headers, body: t0.body, gate: 'primary', laneId: primary.id, durationMs: t0.durationMs };\r\n    }\r\n\r\n    // primary failed -> try fallback(s)\r\n    logger.warn(`[NPZ] primary failed for ${primary.name}, running fallbacks`);\r\n    recordFailure(host, primary.id, t0.durationMs);\r\n\r\n    for (let i = 1; i < ordered.length; i++) {\r\n      const lane = ordered[i];\r\n      const laneUrl = req.url.replace(urlObj.origin, lane.url);\r\n      logger.nez('NPZ', `trying fallback lane ${lane.name} -> ${laneUrl}`);\r\n      const res = await tryFetch(laneUrl, { method: req.method, headers: req.headers, body: req.body }, timeout);\r\n      if (res.ok && res.status && res.status < 500) {\r\n        logger.nez('NPZ', `fallback lane ${lane.name} succeeded`);\r\n        // set preferred to fallback for next time\r\n        setPreferredLane(host, lane.id);\r\n        recordSuccess(host, lane.id, res.durationMs);\r\n\r\n        // replay primary with an extra header (T2)\r\n        const replayHeaders = Object.assign({}, req.headers || {});\r\n        replayHeaders['X-NPZ-FALLBACK'] = '1';\r\n        const replayUrl = primaryUrl;\r\n        logger.nez('NPZ', `replaying primary (${primary.name}) with fallback header`);\r\n        const replay = await tryFetch(replayUrl, { method: req.method, headers: replayHeaders, body: req.body }, timeout);\r\n        if (replay.ok && replay.status && replay.status < 500) {\r\n          logger.nez('NPZ', `replayed primary succeeded after fallback`);\r\n          return { status: replay.status, headers: replay.headers, body: replay.body, gate: 'replay', laneId: primary.id, durationMs: replay.durationMs };\r\n        }\r\n\r\n        // if replay failed, return fallback result\r\n        return { status: res.status, headers: res.headers, body: res.body, gate: 'fallback', laneId: lane.id, durationMs: res.durationMs };\r\n      } else {\r\n        recordFailure(host, lane.id, res.durationMs);\r\n      }\r\n    }\r\n\r\n    // if all failed, return primary error or generic\r\n    logger.warn('[NPZ] all lanes failed');\r\n    if (t0 && !t0.ok) return { error: t0.error, gate: 'fail', durationMs: t0.durationMs };\r\n    return { status: t0.status, body: t0.body, gate: 'fail', durationMs: t0.durationMs };\r\n  } catch (err) {\r\n    return { error: err, gate: 'error' };\r\n  }\r\n}\r\n\r\nexport function getCircuitState(host: string) {\r\n  const m = circuit.get(host);\r\n  if (!m) return {} as Record<number, CircuitState>;\r\n  const out: Record<number, CircuitState> = {};\r\n  for (const [k, v] of m.entries()) out[k] = v;\r\n  return out;\r\n}\r\n\r\nexport default { DEFAULT_LANES, npzRoute, getPreferredLane, setPreferredLane, lanesForHost, recordFailure, recordSuccess, isLaneTripped, getCircuitState };\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\qflush\\src\\utils\\npz-store-redis.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\qflush\\src\\utils\\npz-store.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\qflush\\src\\utils\\npz.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\qflush\\src\\utils\\package.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\qflush\\src\\utils\\paths.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\qflush\\src\\utils\\tokens.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]

